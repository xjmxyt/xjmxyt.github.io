<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TinyWebserver源码阅读（一）</title>
      <link href="/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="主程序的步骤"><a href="#主程序的步骤" class="headerlink" title="主程序的步骤"></a>主程序的步骤</h1><p>在本部分，主要去解析WebServer的四个主要组成部分</p><ul><li>Webserver类：供<code>main</code>函数使用的<code>webserver</code>主类，通过该类可以进行网络通信的各种连接</li><li>Epoll类：通过<code>epoll</code>函数进行系统调用</li><li>Thread类：负责线程池的管理</li><li>Sql资源管理部分<br>从<code>main.cpp</code>中，我们可以看到，主程序做了两件事</li><li>创建一个<code>webServer</code></li><li>调用了<code>server.start()</code> 启动创建的<code>server</code></li></ul><h2 id="1-WebServer类"><a href="#1-WebServer类" class="headerlink" title="1 WebServer类"></a>1 WebServer类</h2><p>下面进入到<code>WebServer</code>类的代码中一探究竟</p><h3 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h3><p>在列表初始化中，初始化了<code>port</code>,<code>Timer</code>,<code>ThreadPool</code>,<code>Epoller</code><br>在构造函数中主要包含了以下步骤</p><ol><li>初始化<code>HttpConn</code>的静态变量，包括<ul><li><code>userCount</code>: 默认为0</li><li><code>srcDir</code>: <code>getcwd + &#39;/resources/&#39;</code></li></ul></li><li>初始化<code>SqlConnPool</code></li><li>初始化<code>Webserver</code>的<code>eventMode_</code></li><li><code>InitSocket_</code>:<ul><li>主要包含初始化socket的各种配置，创建<code>listenFd</code></li></ul></li><li>初始化<code>log</code></li></ol><p><code>InitSocket_</code>具体包含：</p><blockquote><ul><li>创建socket</li><li>设置数据没发送完毕的时候容许逗留（<a href="https://www.cnblogs.com/eeexu123/p/5275783.html">setsockopt用法介绍</a>）<br>  <code>setsockopt(listenFd_, SOL_SOCKET, SO_LINGER, &amp;optLinger, sizeof(optLinger));</code></li><li>设置端口复用 <code>setsockopt(listenFd_, SOL_SOCKET, SO_REUSEADDR, (const void*)&amp;optval, sizeof(int));</code></li><li>bind + listen</li><li>添加fd到监听红黑树上<ul><li>实际通过<code>Epoller</code>类进行操作，核心代码为<code>epoll_ctl(epollFd_, EPOLL_CTL_ADD, fd, &amp;ev)</code></li><li>修改<code>listenFd_</code>为非阻塞: <code>SetFdNonBlock(listenFd_)</code></li></ul></li></ul></blockquote><h3 id="1-2-WebServer的启动"><a href="#1-2-WebServer的启动" class="headerlink" title="1.2 WebServer的启动"></a>1.2 WebServer的启动</h3><p>涉及到的是<code>WebServer Start</code>部分的代码，<code>timeMS</code>表示事件等待超时的时间</p><ol><li>判断<code>isClose_</code>是否为<code>true</code>，不为<code>true</code>时一直停留在循环内部（步骤2-步骤4）</li><li>通过<code>timer</code>更新<code>timeMS</code></li><li>调用<code>int eventCnt = epoller_-&gt;Wait(timeMS);</code>获取满足监听事件的总数</li><li>遍历获取的事件对事件进行处理<ul><li>如果是<code>listenfd_</code>，调用<code>DealListen_()</code></li><li>如果<code>EPOLLRDHUP | EPOLLHUP | EPOLLERROR</code>调用<code>CloseConn_()</code></li><li>如果是<code>EPOLLIN</code>，调用<code>DealRead_()</code></li><li>如果是<code>EPOLLOUT</code>，调用<code>DealWrite_()</code></li></ul></li><li>跳转至步骤1</li></ol><ul><li><code>DealListen_()</code>的处理</li></ul><blockquote><ul><li>调用<code>accept</code><ul><li>出错处理</li></ul></li><li>添加<code>client</code><ul><li>在<code>AddClient_</code>中执行</li><li>包括添加到<code>timer</code>，调用<code>epoller_-&gt;AddFd</code>添加到监听红黑树上，设置<code>nonblock</code>等一系列步骤</li></ul></li></ul></blockquote><ul><li><code>CloseConn_()</code>的处理</li></ul><blockquote><ul><li><code>epoller_-&gt;DelFd()</code></li><li><code>client</code>关闭连接</li></ul></blockquote><ul><li><code>DealRead_()</code>&#x2F;<code>DealWrite_()</code>的处理</li></ul><blockquote><ul><li>延长时间</li><li>加入<code>threadPool</code></li></ul></blockquote><h2 id="2-Epoller类"><a href="#2-Epoller类" class="headerlink" title="2 Epoller类"></a>2 Epoller类</h2><p><code>Epoller</code>非常简单，主要是对<code>epoll</code>操作的封装，内部用<code>vector&lt;struct epoll_event&gt; events</code>存储监听树上的事件<br>主要方法如下</p><ul><li><code>AddFd(int fd, uint32_t event)</code></li><li><code>ModFd(int fd, uint32_t event)</code></li><li><code>DelFd(int fd)</code></li><li><code>Wait(int timeoutMs)</code></li><li><code>GetEventFd(size_t i)</code></li><li><code>GetEvents(size_t i)</code><br>这里可以直接参考<code>epoll</code>的用法</li></ul><h2 id="3-Thread类"><a href="#3-Thread类" class="headerlink" title="3 Thread类"></a>3 Thread类</h2><p>核心代码在<code>pool/threadPool</code>中，在<code>ThreadPool</code>成员变量为<code>Pool</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Pool &#123;    std::mutex mtx;    std::condition_variable cond;    bool isClosed;    std::queue&lt;std::function&lt;void()&gt;&gt; tasks; &#125;; std::shared_ptr&lt;Pool&gt; pool_;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对其进行分析，里面主要含有锁<code>mutex</code>，条件变量<code>cond</code>，是否关闭<code>isClosed</code>，函数组成的队列<code>queue&lt;std::function&lt;void()&gt;&gt; tasks</code><br><code>pool</code>是多个线程之间的共享资源，因为对<code>pool</code>的所有操作都需要先获取锁</p><h3 id="3-1-线程池"><a href="#3-1-线程池" class="headerlink" title="3.1 线程池"></a>3.1 线程池</h3><p>首先来到构造函数，它做的事是</p><ul><li>初始化<code>pool_</code>: 这里采用<code>make_shared</code>进行初始化（<a href="https://www.jianshu.com/p/03eea8262c11">c11 make_shared</a>），构造函数建议使用<code>make_shared</code>而不是<code>new</code>分配对象</li><li>创建<code>threadCount</code>个线程：用<code>detach</code>方法作为后台线程，线程的使用可以参考<a href="https://thispointer.com/c11-multithreading-part-2-joining-and-detaching-threads/">joining-and-detaching-threads</a></li></ul><p>创建的后台线程做的事如下：<br>    - 使用<code>std::unique_lock</code>创建一个锁（<a href="https://blog.csdn.net/shoufei403/article/details/107510476">使用方法</a>），该构造方法会直接对<code>mutex</code>对象加锁<br>    - while循环中<br>        - 当<code>tasks</code>不为空时，可以看到已经获取了<code>lock</code>，取出第一个<code>task</code>，释放<code>lock</code>,执行<code>task</code>，最后获取锁进到下一次循环中<br>        - 当<code>tasks</code>为空时，如果有停止标志，退出循环，否则等待<br>        - 当 <code>std::condition_variable</code> 对象的某个 wait 函数被调用的时候，它使用 <code>std::unique_lock</code>(通过 <code>std::mutex</code>) 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的 <code>std::condition_variable</code> 对象上调用了 <code>notification</code> 函数来唤醒当前线程<br>            - 观察到在<code>addTask</code>方法中， <code>pool_-&gt;cond.notify_one()</code>会将其唤醒</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">explicit ThreadPool(size_t threadCount &#x3D; 8): pool_(std::make_shared&lt;Pool&gt;()) &#123;        assert(threadCount &gt; 0);        for(size_t i &#x3D; 0; i &lt; threadCount; i++) &#123;            std::thread([pool &#x3D; pool_] &#123;                std::unique_lock&lt;std::mutex&gt; locker(pool-&gt;mtx);                while(true) &#123;                    if(!pool-&gt;tasks.empty()) &#123;                        auto task &#x3D; std::move(pool-&gt;tasks.front());                        pool-&gt;tasks.pop();                        locker.unlock();                        task();                        locker.lock();                    &#125;                     else if(pool-&gt;isClosed) break;                    else pool-&gt;cond.wait(locker);                &#125;            &#125;).detach();        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-回调函数的放入"><a href="#3-2-回调函数的放入" class="headerlink" title="3.2 回调函数的放入"></a>3.2 回调函数的放入</h3><p><code>std::function&lt;void()&gt;</code>是可调用对象包装器，可用于<code>callback</code>，参考<a href="https://stackoverflow.com/questions/11352936/why-do-we-use-stdfunction-in-c-rather-than-the-original-c-function-pointer">why use std::function</a>,  <a href="https://stackoverflow.com/questions/55124517/stdfunction-and-stdbind-return-value">std::function and std::bind</a>, <a href="https://blog.csdn.net/Jxianxu/article/details/107382049">std::bind</a></p><p>整个放入到tasks到流程如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">threadpool_-&gt;AddTask(std::bind(&amp;WebServer::OnWrite_, this, client))void AddTask(F&amp;&amp; task) &#123;    &#123;        std::lock_guard&lt;std::mutex&gt; locker(pool_-&gt;mtx);        pool_-&gt;tasks.emplace(std::forward&lt;F&gt;(task));    &#125;    pool_-&gt;cond.notify_one();&#125;std::queue&lt;std::function&lt;void()&gt;&gt; tasks;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::bind</code>将<code>client</code>参数绑定到<code>WebServer::OnWrite_</code>方法，这样返回的<code>functor</code>就变为<code>void()</code>，放入到<code>std::function&lt;void()&gt;</code>可调用对象包装器中。</p><h3 id="3-3-析构函数"><a href="#3-3-析构函数" class="headerlink" title="3.3 析构函数"></a>3.3 析构函数</h3><p>在析构函数中，需要唤醒阻塞的后台进程，使其结束。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">~ThreadPool() &#123;    if(static_cast&lt;bool&gt;(pool_)) &#123;        &#123;            std::lock_guard&lt;std::mutex&gt; locker(pool_-&gt;mtx);            pool_-&gt;isClosed &#x3D; true;        &#125;        pool_-&gt;cond.notify_all();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-Sql资源管理"><a href="#4-Sql资源管理" class="headerlink" title="4 Sql资源管理"></a>4 Sql资源管理</h2><p>主要包含以下文件：<code>sqlConnRAII.h</code>, <code>sqlconnpool.h</code>, <code>sqlconnpool.c</code></p><h3 id="4-1-RAII机制"><a href="#4-1-RAII机制" class="headerlink" title="4.1 RAII机制"></a>4.1 RAII机制</h3><p>RAII（Resource Acquisition Is Initialization）为资源获取即初始化，<code>sqlConnRAII.h</code>专门负责了sql资源的连接，关键代码为在构造函数中调用<code>*sql = connpool-&gt;GetConn();</code>，在析构函数中调用<code>connpool_-&gt;FreeConn(sql_);</code><br>内部成员有两个：</p><ul><li><code>MYSQL *sql_;</code></li><li><code>SqlConnPool* connpool_;</code></li></ul><h3 id="4-2-SqlConnPool"><a href="#4-2-SqlConnPool" class="headerlink" title="4.2 SqlConnPool"></a>4.2 SqlConnPool</h3><p><code>sqlconnpool.h</code>中，静态方法为<code>instance</code>: 它用static声明了一个<code>SqlConnPool</code>对象并返回了一个地址<br>成员方法包括</p><ul><li><code>MYSQL *GetConn()</code></li><li><code>void FreeConn(MYSQL conn)</code></li><li><code>int GetFreeConnCount()</code></li><li><code>void Init(args)</code></li><li><code>void ClosePool()</code><br>成员变量包括</li><li><code>std::queue&lt;MYSQL *&gt; connQue_</code>;</li><li><code>std::mutex mtx_</code>;</li><li><code>sem_t semId_</code>;</li><li><code>int MAX_CONN_</code>;</li></ul><h4 id="4-2-1-Init和ClosePool"><a href="#4-2-1-Init和ClosePool" class="headerlink" title="4.2.1 Init和ClosePool"></a>4.2.1 Init和ClosePool</h4><p>首先来到<code>init</code>方法，它调用<code>connSize</code>次<br>    - <code>mysql_init</code><br>    - <code>mysql_real_connect</code><br>    - 并<code>MYSQL</code>对象添加到<code>connQue_</code>中<br>之后初始化<code>MAC_CONN_</code>和初始化信号量<code>semId_</code>为<code>MAX_CONN_</code><br>在<code>ClosePool</code>中，主要做的事情是清空<code>connQue_</code>,调用<code>mysql_library_end</code>结束<code>mysql</code></p><h4 id="4-2-2-GetConn和FreeConn"><a href="#4-2-2-GetConn和FreeConn" class="headerlink" title="4.2.2 GetConn和FreeConn"></a>4.2.2 GetConn和FreeConn</h4><p>这里采用sem和<a href="https://blog.csdn.net/fengbingchun/article/details/78649260">lock_guard</a>对多线程并发访问进行控制，<code>sem_wait</code>和<code>sem_post</code>对连接数进行原子操作，<code>lock_guard</code>在构造时会自动获取锁，析构时会释放锁，用来取出<code>sql</code>对象</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MYSQL* SqlConnPool::GetConn() &#123;    MYSQL *sql &#x3D; nullptr;    if(connQue_.empty())&#123;        LOG_WARN(&quot;SqlConnPool busy!&quot;);        return nullptr;    &#125;    sem_wait(&amp;semId_);    &#123;        lock_guard&lt;mutex&gt; locker(mtx_);        sql &#x3D; connQue_.front();        connQue_.pop();    &#125;    return sql;&#125;void SqlConnPool::FreeConn(MYSQL* sql) &#123;    assert(sql);    lock_guard&lt;mutex&gt; locker(mtx_);    connQue_.push(sql);    sem_post(&amp;semId_);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>c11语法: <a href="https://www.codeproject.com/Articles/312029/Cplusplus-A-Glance-Part-of-n">Cplusplus-A-Glance-Part-of-n</a></li><li>c++多线程编程：<a href="https://www.cnblogs.com/haippy/p/3235560.html">C++11 并发指南</a></li><li>writev和readv：<a href="https://blog.csdn.net/weixin_36750623/article/details/84579243">高级I&#x2F;O之readv和writev函数</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webserver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824——GFS文件系统</title>
      <link href="/2022/12/15/MIT6-824%E2%80%94%E2%80%94GFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/15/MIT6-824%E2%80%94%E2%80%94GFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统——GFS文件系统"><a href="#分布式系统——GFS文件系统" class="headerlink" title="分布式系统——GFS文件系统"></a>分布式系统——GFS文件系统</h1><p>参考论文: <a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf">https://pdos.csail.mit.edu/6.824/papers/gfs.pdf</a></p><p><img src="/images/pasted-0.png"></p><p><img src="/images/pasted-1.png"></p><p><img src="/images/pasted-2.png"></p><p><img src="/images/pasted-3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
