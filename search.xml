<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cuda编程学习指南</title>
      <link href="/2023/12/14/cuda%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
      <url>/2023/12/14/cuda%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵乘">矩阵乘</h2><p>最简单的写法是每一个线程都去计算矩阵A的每一行和矩阵B的每一列 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define N 1024__global__ void mult(float *a, float *b, float *c)&#123;int ny &#x3D; blockDim.x * blockIdx.x + threadIdx.x;    int nx &#x3D; blockDim.y * blockIdx.y + threadIdx.y;    float sum &#x3D; 0;    for(int i&#x3D;0; i&lt;N; ++i)&#123;    sum +&#x3D; a[nx*N + i] * b[i*N + ny];    &#125;    c[nx*N + ny] &#x3D; sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>之后利用矩阵分块和shared mem进行优化 思路就是现在每次我们需要计算A矩阵的一行和B矩阵的一列，因此我们把A矩阵划分成为nblock=N/BLOCK_SIZE，B矩阵同理，这样相乘的时候就是对应block相乘，算完之后再算block的相加操作。</p><p>里面较为关键的计算有：astep对于A中下一个block的位置，因为是按照行所以是BLOCK_SIZE，bstep对于B中下一个block的位置，因为是按照列，下一个block离现在有BLOCK_SIZE行，所以是BLOCK_SIZE*N <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define BLOCK_SIZE 32#define N 1 &lt;&lt; 16__global__ void mult(float *a, float b, float *c)&#123;int tx &#x3D; threadIdx.x;    int ty &#x3D; threadIdx.y;    int bx &#x3D; blockIdx.x;    int by &#x3D; blockIdx.y;    int astep &#x3D; BLOCK_SIZE;    int bstep &#x3D; BLOCK_SIZE * N;    int astart &#x3D; BLOCK_SIZE * by * N;    int bstart &#x3D; BLOCK_SIZE * bx;        float total &#x3D; 0;    int nblock &#x3D; N&#x2F;BLOCK_SIZE;    __shared__ float A[BLOCK_SIZE][BLOCK_SIZE];    __shared__ float B[BLOCK_SIZE][BLOCK_SIZE];    for(int i&#x3D;0; i&lt;nblock; ++i)&#123;    A[ty][tx] &#x3D; a[astart + i*astep + ty*N + tx];        B[ty][tx] &#x3D; b[bstart + i*bstep + ty*N + tx];                &#x2F;&#x2F; 这里保证了一个block的线程都进行了同步        __syncthreads();                &#x2F;&#x2F; 之后其实对该block中的线程的计算结果进行了求和，这些结果都保存在shared memory中        for(int k&#x3D;0; k&lt;BLOCK_SIZE; ++k)&#123;        total +&#x3D; A[ty][i] * B[i][tx];        &#125;    &#125;    int cstart &#x3D; by * N * BLOCK_SIZE + bx * BLOCK_SIZE;    c[cstart + &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="parallel-reduction">parallel reduction</h2><p><img src="/images/pasted-7.png" alt="upload successful" /> <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__global__ void sum(int* input)&#123;const int tid &#x3D; threadIdx.x;    int step &#x3D; 1;    int nthread &#x3D; blockDim.x;    while(nthread &gt; 0)&#123;    if(tid &lt; nthread)&#123;        int start &#x3D; tid * step * 2;        input[start] +&#x3D; input[start + step];            nthread &gt;&gt;&#x3D; 1;            step &lt;&lt;&#x3D; 1;        &#125;    &#125;&#125;int main()&#123;int n &#x3D; 8;int h[]&#x3D; &#123;13, 27, 15, 14, 33, 2, 24, 6&#125;;    int *d;    cudaMalloc(&amp;d, sizeof(int)*n);    cudaMemcpy(d, h, sizeof(int)*n, cudaMemcpyHostToDevice);    sum&lt;&lt;&lt;1, n&#x2F;2&gt;&gt;&gt;(d);    int result;    cudaMemcpy(&amp;result, d, sizeof(int), cudaMemcpyDeviceToHost);    cudaFree(d);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ray学习指南</title>
      <link href="/2023/05/18/Ray%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
      <url>/2023/05/18/Ray%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="总体介绍">总体介绍</h2><h3 id="why-ray">Why Ray</h3><p>当我们要构建一个涉及大规模数据处理或者复杂计算的应用，传统的方式是使用现成的大数据框架，例如 Apache Flink 和 Apache Spark。这些系统提供的API通常基于某种特定的计算范式（例如DataStream、DataSet），要求用户基于这些特定的计算范式实现应用逻辑。对于传统的数据清洗、数据分析等应用，这种用法能够很好地适用。但是，随着分布式应用的逻辑越来越复杂（例如分布式机器学习应用），许多应用的逻辑并不能直接套用现有的计算范式。在这种情况下，开发者如果想要细粒度地控制系统中的任务流，就需要自己从头编写一个分布式应用。</p><p>但是现实中，开发一个分布式应用并不简单。除了应用本身的代码逻辑，我们还需要处理许多分布式系统中常见的难题，例如：分布式组件通信、服务部署、服务发现、监控、异常恢复等。处理这些问题，通常需要开发者在分布式系统领域有较深的经验，否则很难保证系统的性能和健壮性。</p><p>为了简化分布式编程，Ray提供了一套简单、通用的分布式编程API，屏蔽了分布式系统中的这些常见的难题，让开发者能够使用像开发单机程序一样简单的方式，开发分布式系统。Ray的API基于两个核心的概念：Task和Actor。</p><h3 id="what-is-ray">What is Ray</h3><p>Ray是针对扩展AI和Python应用例如机器学习的开源联合框架。它为并行处理提供了计算层，因此你不用担心成为一个分布式系统专家。Ray通过以下三种方式减小了运行分布式个人和端到端的机器学习工作流程。 - 供类似数据处理、分布式训练、超参调优、强化学习、模型服务等常见机器学习任务使用的可扩展库 - 针对并行和扩展Python应用提供Pythonic的分布式计算原语 - 集成并提供了整合和用现有工具和基础设施如Kubernetes,AWS,GCP,Azure部署Ray集群的功能</p><p>针对数据科学家和机器学习实践者，Ray能让你不需要分布式的专业知识扩展应用。 - 容易在多个节点和GPU之间并行和分配工作负载 - 迅速配置和获取云计算资源 - 利用带有本机和可扩展集成的ML生态系统</p><p>针对分布式系统工程师，Ray 自动化的处理以下关键过程： - 协调——管理分布式系统中的不同的组建 - 调度——统筹什么时候和在哪儿任务可以被执行 - 容错——忽视不可避免的错误确保任务的完成 - 自动化扩展——调整分配给动态需求的资源数量</p><figure><img src="/images/pasted-5.png" alt="Ray架构" /><figcaption aria-hidden="true">Ray架构</figcaption></figure><figure><img src="/images/pasted-6.png" alt="Ray组成部分" /><figcaption aria-hidden="true">Ray组成部分</figcaption></figure><p>Ray AI Runtime涉及的和机器学习关系比较大，针对特定领域（类似Spark的Mlib）</p><p>Ray Core针对一般用途的分布式计算库去扩展Python应用，加速机器学习的工作负载</p><p>Ray Cluster一组连接到通用Ray head node的工作节点。</p><p>Ray Air的五个原生库都被分配到一个特定的ML任务 - Data:可扩展的，跨训练、微调、预测的框架无关的数据加载和转换 - Train:分布式多节点和多核模型的整合了流行训练库的具有容错机制的训练 - Tune:可扩展的超参调优去优化模型表现 - Serve:可扩展和编程的服务去部署在线推理模型，</p><h2 id="reference">Reference</h2><p><a href="https://ray.osanswer.net/t/topic/41">分布式计算框架Ray介绍</a></p><p><a href="https://docs.ray.io/en/latest/ray-overview/index.html">Ray doc</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python基础知识</title>
      <link href="/2023/04/27/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/04/27/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="零零碎碎的知识点">零零碎碎的知识点</h2><ul><li>python的模块搜索路径：<ul><li>内置模块</li><li>在<code>sys.path</code>的路径中进行查找：1. python执行所在的入口文件所在路径；2. 系统环境变量<code>PYTHON_PATH</code>所表示的目录； 3. <code>site</code>路径，如<code>/usr/local/lib/python3.5/site-packages</code></li></ul></li><li>包的导入：<ul><li>包和模块：包是文件夹，模块是文件</li><li>只有含有<code>__init__.py</code>才能被称为包，否则python会无法识别</li><li>在<code>__init__.py</code>中会引入<code>__all__</code>变量，用于批量导入。</li></ul></li></ul><h2 id="reference">reference</h2><p><a href="https://jarvisma.gitbook.io/pythonlearn">python简单入门指北</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023春招笔试记录</title>
      <link href="/2023/03/18/2023%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/03/18/2023%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="morgan">Morgan</h2><h3 id="profit-analysis">Profit Analysis</h3><p>A data analyst wants to analyze the performance of his investments in the HackShare stock. The PnL of his portfolio is represented by an array prl where pnl[i] represents the profit earned in the ith month that can possibly be negative indicating a loss.</p><p>Given the pnl array of n months, find the maximum net profit (sum of profits) gained in any contiguous segment of months i.e. a subarray of months such that the number of months in the segment does not exceed a given integer k.</p><h4 id="example">Example</h4><p>Giver n=6. pnl = [-3, 4, 3, -2, 2, 5], k=4, We can select the subarray [3, -2, 2, 5] with a total profit 3 + (-2) + 2 + 5 = 8. Note that while the maximum net profit of a subarray can be 12 for the subarray [4, 3, -2, 2, 5] but the length of the subarray will exceed K = 4. Hence, we report 8 as the answer.</p><h4 id="function-description">Function Description</h4><p>Complete the function getMaxProfit in the editor below. getMaxProfit has the following parameters: pnl[n]: An array of integers k. An integer</p><h4 id="solution">Solution</h4><p>用<code>nlog(n)</code>的复杂度，map维护前面元素的最小值，如果超出了k的范围则弹出 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;long getMaxProfit(vector&lt;int&gt; &amp;a, int k)&#123;    &#x2F;&#x2F; prefix sum    int n &#x3D; a.size();    vector&lt;long&gt; s(n+1);    for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;        s[i] &#x3D; s[i-1] + a[i-1];    &#125;    map&lt;long, int, less&lt;long&gt;&gt; sum2pos;    sum2pos[0] &#x3D; 0;    long ans &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;        while(sum2pos.begin()-&gt;second + k &lt; i) sum2pos.erase(sum2pos.begin());        ans &#x3D; max(ans, s[i] - sum2pos.begin()-&gt;first);        sum2pos[s[i]] &#x3D; i;    &#125;    return ans;&#125;int main()&#123;    vector&lt;int&gt; a &#x3D; &#123;-3, 4, -5, 32, -10, 3, -2, 2, 5&#125;;    int k &#x3D; 4;    cout &lt;&lt; getMaxProfit(a, k) &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="dna-sequencing">DNA Sequencing</h3><p>Some data scientists are building a utility to analyze palindromic trends in the DNA sequencing of a string. The palindrome transformation cost of a string is defined as the minimum number of characters that need to be changed in it so that it can be rearranged to form a palindrome. For example, the palindrome transformation cost of the string "aabcd" is 1 as we can change the last character 'd' to 'c'so that the string becomes "aabcc" that can be rearranged to "acbca" which is a palindrome.</p><p>Given string dna, find the total sum of palindrome transformation cost of all the substrings of the given string.</p><p>Note: A palindrome is a sequence that reads the same backward as forward, for example, sequences "z", "aba" and "aaa" are palindromes, but sequences "×y", "rank" are not.</p><h4 id="example-1">Example</h4><p>Suppose dna = "abca", substrings of dna with their costs are- - "a", "b", "c", "a", with cost = 0 - "ab", cost = 1, we can change 'b' to 'a' and it becomes "aa" which is a palindrome. - "abc", cost = 1, we can change 'b' to 'c' and it can be rearranged to "cac" which is a palindrome.</p><h4 id="solution-1">Solution</h4><p>用state记录每个字符的奇偶状态，转化为回文串的操作次数为 <strong>奇数字母的个数/2</strong>, 遍历开始节点和长度，从上一个状态中推导下一个状态 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;#define GETBIT(state, k) (state &gt;&gt; k) &amp; 1#define SETBIT(state, k) state |&#x3D; (1 &lt;&lt; k)#define CLEARBIT(state, k) state &amp;&#x3D; ~(1 &lt;&lt; k)int get_trans_cnt(int cnt)&#123;    return cnt &#x2F; 2;&#125;long getMaxProfit(string s)&#123;    int n &#x3D; s.size();    long ans &#x3D; 0;    for(int i &#x3D; 0; i &lt; n; ++i)&#123;        int cnt &#x3D; 0;        int state &#x3D; 0;        for(int l &#x3D; 1; i + l - 1 &lt; n; ++l)&#123;            int j &#x3D; i + l - 1;            int k &#x3D; s[j] - &#39;a&#39;;            if(GETBIT(state, k))&#123;                &#x2F;&#x2F; already exist                cnt --;                ans +&#x3D; get_trans_cnt(cnt);                CLEARBIT(state, k);            &#125;else&#123;            &#x2F;&#x2F; not exist                cnt ++;                ans +&#x3D; get_trans_cnt(cnt);                SETBIT(state, k);            &#125;        &#125;    &#125;    return ans;&#125;int main()&#123;    cout &lt;&lt; getMaxProfit(&quot;abca&quot;) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="阿里-2023">阿里 2023</h2><p>[题目内容] 给定一棵二又树，试求这棵二叉树有多少个节点满足以该节点为根的子树是满二叉树?</p><p>我们定义一棵树是满二叉树，当且仅当每一层的节点数量都达到了最大值(即无法在这一层添加新节点)。</p><p>输入描述 第一行输入一个正整数n，代表节点的数量。</p><p>接下来的n行，第i行输入两个整数<span class="math inline">\(l_i\)</span>，代表i号节点的左儿子和右儿子。请注意，如果一个节点没有左儿子/右儿子，则对应为-1</p><p>输出描述 子树为满二又树的节点数量。</p><p>样例1 输入 <pre class="line-numbers language-none"><code class="language-none">52 34 5-1 -1-1 -1-1 -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 输出 <pre class="line-numbers language-none"><code class="language-none">4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> 说明 2, 3, 4, 5号节点的子树都是满二叉树 ### solution <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;struct TreeNode&#123;    TreeNode *left;    TreeNode *right;    int val;    TreeNode(): left(nullptr), right(nullptr), val(0) &#123;&#125;    TreeNode(int val): left(nullptr), right(nullptr), val(val) &#123;&#125;    TreeNode(TreeNode *left, TreeNode *right, int val): left(left), right(right), val(val) &#123;&#125;&#125;;vector&lt;TreeNode *&gt; v;unordered_map&lt;TreeNode *, int&gt; mp;int get_height(TreeNode *node)&#123;    if(mp.find(node)!&#x3D;mp.end()) return mp[node];    if(node&#x3D;&#x3D;nullptr) return 0;    if(node-&gt;left&#x3D;&#x3D;nullptr &amp;&amp; node-&gt;right&#x3D;&#x3D;nullptr) return 1;    int l_h &#x3D; get_height(node-&gt;left);    int r_h &#x3D; get_height(node-&gt;right);    int ans &#x3D; 0;    if(l_h !&#x3D; r_h) ans &#x3D; 0;    else ans &#x3D; l_h + 1;    mp[node] &#x3D; ans;    return ans;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    v.resize(n+1);    for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;        TreeNode *node &#x3D; new TreeNode();        v[i] &#x3D; node;    &#125;    for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        if(a!&#x3D;-1)&#123;            v[i]-&gt;left &#x3D; v[a];        &#125;        if(b!&#x3D;-1)&#123;            v[i]-&gt;right &#x3D; v[b];        &#125;    &#125;    vector&lt;int&gt; ans;    for(int i&#x3D;1; i &lt;&#x3D; n; ++i)&#123;        if(get_height(v[i]))&#123;            ans.push_back(i);        &#125;    &#125;    cout &lt;&lt; ans.size();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="第二题">第二题</h3><p>http://101.43.147.120/p/P1083/submit <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;map&lt;int, long long&gt; mp;long long calculate(vector&lt;int&gt; &amp;v)&#123;    &#x2F;&#x2F;sort(v.begin(), v.end());    for(auto &amp;item: v) mp[item] ++;    map&lt;int, long long&gt;::iterator it &#x3D; mp.begin();    int n &#x3D; v.size();    long long ans &#x3D; 0;    while(it !&#x3D; mp.end())&#123;        auto it1 &#x3D; next(it, 1);        if(it-&gt;first &#x3D;&#x3D; it1-&gt;first - 1)&#123;            auto num1 &#x3D; it-&gt;second;            auto num2 &#x3D; it1-&gt;second;            if(num1 + num2 &gt;&#x3D;3)&#123;                ans +&#x3D; num2 * (num1-1) * num1 &#x2F; 2;                ans +&#x3D; num1 * (num2-1) * num2 &#x2F; 2;            &#125;        &#125;        it ++;    &#125;    return ans;&#125;int main()&#123;    int n &#x3D; 0;    cin &gt;&gt; n;    vector&lt;int&gt; v(n);    for(int i &#x3D; 0; i &lt; n; ++i) cin &gt;&gt; v[i];    cout &lt;&lt; calculate(v);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ### 第三题 http://101.43.147.120/p/P1084 分成三段区间，最大值是三段区间的最大值，最小值是三段区间的最小值 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;using ll &#x3D; long long;long long calculate(vector&lt;int&gt; &amp;v, int k)&#123;    sort(v.begin(), v.end());    int n &#x3D; v.size();    ll res &#x3D; INT_MAX;    for(int i &#x3D; 0 ; i&lt;&#x3D;k; ++i)&#123;        int j &#x3D; k - i;        &#x2F;*        [0, i-1], [i, n-j-1], [n-j, n-1]        *&#x2F;        int min_1 &#x3D; INT_MAX, max_1 &#x3D; INT_MIN;        int min_2 &#x3D; INT_MAX, max_2 &#x3D; INT_MIN;        int min_3 &#x3D; INT_MAX, max_3 &#x3D; INT_MIN;        if(i-1 &gt;&#x3D; 0)&#123;            min_1 &#x3D; v[0] * 2;            max_1 &#x3D; v[i-1] * 2;        &#125;        if(i&lt;&#x3D;n-j-1)&#123;            min_2 &#x3D; v[i];            max_2 &#x3D; v[n-j-1];        &#125;        if(n-j &lt;&#x3D; n-1)&#123;            min_3 &#x3D; v[n-j]&#x2F;2;            max_3 &#x3D; v[n-1]&#x2F;2;        &#125;        int t_min &#x3D; min(min(min_1, min_2), min_3);        int t_max &#x3D; max(max(max_1, max_2), max_3);        &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; t_min &lt;&lt; &quot; &quot; &lt;&lt; t_max &lt;&lt; endl;        ll ans &#x3D; t_max - t_min;        res &#x3D; min(ans, res);    &#125;    return res;&#125;int main()&#123;    int n &#x3D; 0;    cin &gt;&gt; n;    int k;    cin &gt;&gt; k;    vector&lt;int&gt; v(n);    for(int i &#x3D; 0; i &lt; n; ++i) cin &gt;&gt; v[i];    cout &lt;&lt; calculate(v, k);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="reference">reference</h2><p>位运算的技巧 https://www.cnblogs.com/RioTian/p/13598747.html</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>miniob项目总结</title>
      <link href="/2022/12/25/miniob%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2022/12/25/miniob%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="存储部分">存储部分</h2><ul><li><code>BufferPoolManager</code>管理<code>file</code>到<code>BufferPool</code>的映射关系（一对多）</li><li><code>BufferPool</code>管理文件和磁盘的映射关系</li><li><code>BPFrameManager</code>管理文件和<code>Frame</code>之间的关系，从<code>fd+page_num</code>就可以获取对应的页</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct Page&#123;PageNum page_num;    char data[BP_PAGE_DATA_SIZE];&#125;;struct BPFileHeader&#123;int32_t page_count; &#x2F;&#x2F; 当前文件一共多少页面    int32_t allocated_pages; &#x2F;&#x2F; 已经分配了多少页面&#125;class Frame&#123;private:  bool          dirty_     &#x3D; false;  unsigned int  pin_count_ &#x3D; 0;  unsigned long acc_time_  &#x3D; 0;  int           file_desc_ &#x3D; -1;  Page          page_;&#125;;class BPFrameManager&#123;public:  Frame *get(int file_desc, PageNum page_num);  Frame *alloc(int file_desc, PageNum page_num);  Frame *begin_purge();&#x2F;&#x2F;从后往前遍历frames_，找到能被清理的frameprivate:  std::mutex lock_;  FrameLruCache frames_;  FrameAllocator allocator_;&#125;;class BufferPoolIterator&#123;public:  BufferPoolIterator();  ~BufferPoolIterator();  RC init(DiskBufferPool &amp;bp, PageNum start_page &#x3D; 0);  bool has_next();  PageNum next();  RC reset();private:  common::Bitmap   bitmap_;  PageNum  current_page_num_ &#x3D; -1;&#125;;class DiskBufferPool&#123;public:  RC create_file(const char *file_name);  RC open_file(const char *file_name);&#x2F;&#x2F;打开文件，加载hdr_frame_和file_header  RC flush_page(Frame &amp;frame); &#x2F;&#x2F;将数据刷新写回磁盘，可以从file_desc_和pageNum找到要写入的位置，然后将frame的内容写入protected:  RC load_page(PageNum page_num, Frame *frame);&#x2F;&#x2F;从file_desc_中加载相应的offset到frame中private:  BufferPoolManager &amp;bp_manager_;  BPFrameManager &amp;   frame_manager_;  std::string        file_name_;  int                file_desc_ &#x3D; -1;  Frame *            hdr_frame_ &#x3D; nullptr;  BPFileHeader *     file_header_ &#x3D; nullptr;  std::set&lt;PageNum&gt;  disposed_pages;&#125;class BufferPoolManager&#123;private:  BPFrameManager frame_manager_&#123;&quot;BufPool&quot;&#125;;  std::unordered_map&lt;std::string, DiskBufferPool *&gt; buffer_pools_;  std::unordered_map&lt;int, DiskBufferPool *&gt; fd_buffer_pools_;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="parse-stage">parse stage</h2><h3 id="解析部分结构体的定义">解析部分结构体的定义</h3><p>以<code>select</code>为例，分为<code>attribute</code>,<code>relation</code>,<code>condition</code>三个部分，<code>update</code>分为<code>relation_name</code>,<code>attribute_name</code>,<code>value</code>,<code>condition</code>三部分 总的说来，<code>attribute</code>是需要更改的属性，<code>relation</code>是涉及到的<code>table</code>的名字，<code>condition</code>是<code>where</code>后面的条件，<code>value</code>是赋予的取值</p><p>在定义了不同的语句之后，用<code>union</code>结构体存储下来，定义<code>Query</code>来表明输入的语句，里面存有<code>union</code>结构体，和表明该结构是什么类型 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct _Condition &#123;  int left_is_attr;    &#x2F;&#x2F; TRUE if left-hand side is an attribute                       &#x2F;&#x2F; 1时，操作符左边是属性名，0时，是属性值  Value left_value;    &#x2F;&#x2F; left-hand side value if left_is_attr &#x3D; FALSE  RelAttr left_attr;   &#x2F;&#x2F; left-hand side attribute  CompOp comp;         &#x2F;&#x2F; comparison operator  int right_is_attr;   &#x2F;&#x2F; TRUE if right-hand side is an attribute                       &#x2F;&#x2F; 1时，操作符右边是属性名，0时，是属性值  RelAttr right_attr;  &#x2F;&#x2F; right-hand side attribute if right_is_attr &#x3D; TRUE 右边的属性  Value right_value;   &#x2F;&#x2F; right-hand side value if right_is_attr &#x3D; FALSE&#125; Condition;&#x2F;&#x2F; struct of selecttypedef struct &#123;  size_t attr_num;                &#x2F;&#x2F; Length of attrs in Select clause  RelAttr attributes[MAX_NUM];    &#x2F;&#x2F; attrs in Select clause  size_t relation_num;            &#x2F;&#x2F; Length of relations in Fro clause  char *relations[MAX_NUM];       &#x2F;&#x2F; relations in From clause  size_t condition_num;           &#x2F;&#x2F; Length of conditions in Where clause  Condition conditions[MAX_NUM];  &#x2F;&#x2F; conditions in Where clause&#125; Selects;&#x2F;&#x2F; struct of updatetypedef struct &#123;  char *relation_name;            &#x2F;&#x2F; Relation to update  char *attribute_name;           &#x2F;&#x2F; Attribute to update  Value value;                    &#x2F;&#x2F; update value  size_t condition_num;           &#x2F;&#x2F; Length of conditions in Where clause  Condition conditions[MAX_NUM];  &#x2F;&#x2F; conditions in Where clause&#125; Updates;&#x2F;&#x2F; struct of flag and sql_structtypedef struct Query &#123;  enum SqlCommandFlag flag;  union Queries sstr;&#125; Query;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ## resolve stage ### stmt 最关键的模块是<code>Stmt</code>的<code>create_stmt</code>函数(<code>static</code>方法)，所有的<code>Stmt</code>都继承了该类，例如<code>SelectStmt</code>,<code>InsertStmt</code>等，该<code>Stmt</code>会被流转到下一个阶段</p><h3 id="table相关的内存结构">table相关的内存结构</h3><p>将最初的<code>sql</code>结构体转化为<code>statement</code>结构体，检查<code>table</code>是否存在，把要用到的<code>table</code>放进<code>stmt</code>中，把<code>*</code>展开为属性放进<code>stmt</code>中，隐式类型转换等等 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Field&#123;  const Table *table_ &#x3D; nullptr;  const FieldMeta *field_ &#x3D; nullptr;&#125;class FieldMeta&#123;  std::string name_;  AttrType attr_type_;  int attr_offset_;  int attr_len_;  bool visible_;&#125;class TableMeta&#123;  std::string name_;  std::vector&lt;FieldMeta&gt; fields_;  &#x2F;&#x2F; 包含sys_fields  std::vector&lt;IndexMeta&gt; indexes_;  int record_size_ &#x3D; 0;  &#x2F;&#x2F;@@@ TODO why used static variable?  static std::vector&lt;FieldMeta&gt; sys_fields_;&#125;class Table&#123;  std::string base_dir_;  CLogManager *clog_manager_;  TableMeta table_meta_;  DiskBufferPool *data_buffer_pool_ &#x3D; nullptr;   &#x2F;&#x2F;&#x2F; 数据文件关联的buffer pool  RecordFileHandler *record_handler_ &#x3D; nullptr;  &#x2F;&#x2F;&#x2F; 记录操作  std::vector&lt;Index *&gt; indexes_;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="filter_stmt的设计">filter_stmt的设计</h3><p>分为<code>FilterUnit</code>和<code>FilterStmt</code>，对于形如<code>condition1 and condition2</code>这样的语句，<code>condition1</code>作为一个<code>FilterUnit</code>，而<code>FilterStmt</code>存储的是多个<code>FilterStmt</code>的和</p><p>下面来到<code>FilterUnit</code>的设计，<code>FilterUnit</code>可以拆解为<code>Expression op Expression</code>，因此只需要包含这几个结构 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class FilterUnit&#123;  CompOp comp_ &#x3D; NO_OP;  Expression *left_ &#x3D; nullptr;  Expression *right_ &#x3D; nullptr;&#125;class FilterStmt &#123;std::vector&lt;FilterUnit *&gt;  filter_units_;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="expression的设计">expression的设计</h3><p><code>TupleCell</code>和<code>Tuple</code>的定义 - <code>TupleCell</code>存储了真正的数据，调用<code>tuple</code>的<code>cell_at(index, cell)</code>方法可以用<code>table</code>中的数据填充其值 - <code>Tuple</code>是一个抽象类，派生出的对象包括<code>RowTuple</code>和<code>ProjectTuple</code>，它是<code>Operator</code>会返回的值 - <code>RowTuple</code>: 包含了<code>record</code>, <code>table</code>, <code>vector&lt;TupleCellSpec *&gt;</code> - <code>ProjectTuple</code>：包含了<code>vector&lt;TupleCellSpec *&gt;</code>, <code>tuple</code> - <code>TupleCellSpec</code>包含<code>Expression</code> - <code>Expression</code>作为抽象类，包括<code>FieldExpr</code>和<code>ValueExpr</code>，<code>FieldExpr</code>包含<code>Field</code>，<code>ValueExpr</code>包含<code>TupleCell</code> - <code>FieldExpr</code>：包含<code>Field</code> - <code>ValueExpr</code>：包含<code>TupleCell</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class TupleCell&#123;  AttrType attr_type_ &#x3D; UNDEFINED;  int length_ &#x3D; -1;  char *data_ &#x3D; nullptr; &#x2F;&#x2F; real data. no need to move to field_meta.offset&#125;class TupleCellSpec&#123;  const char *alias_ &#x3D; nullptr;  Expression *expression_ &#x3D; nullptr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="execute-stage">Execute Stage</h2><h3 id="总体流程">总体流程</h3><p>通过<code>stmt-&gt;type</code>转到对应的执行函数，执行函数使用算子进行组装，下面以do_select为例进行讲解 <pre class="line-numbers language-none"><code class="language-none">1. 首先做existence check2. 创建ScanOperator, PredicateOperator, ProjectOperator, ScanOperator作为PredicateOperator的child，PredicateOperator作为ProjectOperator的child，这样一层层的调用next函数，就能获得最下层的结果3. 结果存储在ProjectOperator的current_tuple[Tuple]中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre> ### Operator的定义 基类为<code>Operator</code>，主要包含了<code>open</code>, <code>next</code>, <code>close</code>, <code>current_tuple</code>, <code>add_child</code>方法 定义如下 <pre class="line-numbers language-none"><code class="language-none">class Operator&#123;public:  Operator()  &#123;&#125;  virtual ~Operator() &#x3D; default;  virtual RC open() &#x3D; 0;  virtual RC next() &#x3D; 0;  virtual RC close() &#x3D; 0;  virtual Tuple * current_tuple() &#x3D; 0;  &#x2F;&#x2F;virtual int tuple_cell_num() const &#x3D; 0;  &#x2F;&#x2F;virtual RC  tuple_cell_spec_at(int index, TupleCellSpec *&amp;spec) const &#x3D; 0;  void add_child(Operator *oper) &#123;    children_.push_back(oper);  &#125;protected:  std::vector&lt;Operator *&gt; children_;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>最关键的函数是<code>next</code>，其主要功能是 - 调用<code>child.next</code>让<code>child</code>进行下一步操作 - 调用<code>child.current_tuple</code>获取<code>child</code>的现在的元素(<code>tuple</code>) - 调用自己的方法对<code>tuple</code>进行处理，搭配传入的<code>stmt</code>进行运算</p><p>例如，对于<code>PredicateOperator</code>做的事如下： - 一直调用下一层的<code>next</code>方法，对获得的<code>tuple</code>判断是否符合条件 - 不符合就一直循环到符合条件返回 - 比较时采用<code>do_predicate</code>函数 - 通过<code>filter_stmt_</code>获取左右两边的<code>expression</code>，<code>expression</code>的<code>getValue</code>方法能从<code>Tuple</code>中把值获取到<code>TupleCell</code>中 - 调用<code>TupleCell</code>的<code>compare</code>方法 - 返回结果</p><p>对于<code>TableScanner</code>做的事是 - 在<code>open</code>阶段就初始化必要的成员变量 - 在<code>next</code>方法中，用<code>RecordScanner</code>的<code>fetch_next_record</code>去获得记录<code>Record</code> - 如果在一个页中 - 实际上是采用的<code>RecordPageIterator</code>去取得记录 - 通过<code>bitmap_</code>去取得<code>SlotNum</code>，然后用<code>frame_-&gt;data() + page_header_-&gt;first_record_offset + (page_header_-&gt;record_size * slot_num)</code>取得<code>record</code>的值 - 如果不在一个页面中 - <code>BufferPoolIterator</code>会去通过<code>bitmap</code>取得下一个<code>pageNum</code> - 返回值是<code>Tuple</code>，里面包含了<code>Record</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Record&#123;  RID                            rid_;  char *                         data_ &#x3D; nullptr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常用容器代码</title>
      <link href="/2022/12/20/%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E4%BB%A3%E7%A0%81/"/>
      <url>/2022/12/20/%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针">智能指针</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;template&lt;class T&gt;class my_shared_ptr&#123;public:    my_shared_ptr(): _useCnt(new size_t(0)), _ptr(new T()) &#123;&#125;    explicit my_shared_ptr(T *p): _ptr(p), _useCnt(new size_t)&#123;        if (p)&#123;            *_useCnt &#x3D; 1;        &#125;else&#123;            *_useCnt &#x3D; 0;        &#125;    &#125;    &#x2F;&#x2F; copy construct     my_shared_ptr(const my_shared_ptr&amp; other)&#123;        _ptr &#x3D; other._ptr;        _useCnt &#x3D; other._useCnt;        (*_useCnt) ++;    &#125;    &#x2F;&#x2F; copy assignment     my_shared_ptr&amp; operator&#x3D; (const my_shared_ptr&amp; other)&#123;        if(this !&#x3D; &amp;other)&#123;            if(_ptr)&#123;                --(*_useCnt);                if(*_useCnt &#x3D;&#x3D; 0)&#123;                    delete _useCnt;                    delete _ptr;                &#125;                _useCnt &#x3D; other._useCnt;                _ptr &#x3D; other._ptr;                ++(*_useCnt);            &#125;        &#125;        return *this;    &#125;    int use_count()&#123;        return *_useCnt;    &#125;    ~my_shared_ptr()&#123;        if(!_ptr || ((*_useCnt)&#x3D;&#x3D;1))&#123;            delete _useCnt;            delete _ptr;        &#125;else&#123;            --(*_useCnt);        &#125;    &#125;private:    size_t * _useCnt;    T * _ptr;&#125;;int main()&#123;    my_shared_ptr&lt;int&gt; p1(new int(1));    cout &lt;&lt; &quot;p1 cnt:&quot; &lt;&lt; p1.use_count() &lt;&lt; endl;    &#123;        my_shared_ptr&lt;int&gt; p2(p1);        cout &lt;&lt; &quot;p2 cnt:&quot; &lt;&lt; p2.use_count() &lt;&lt; endl;        cout &lt;&lt; &quot;p1 cnt:&quot; &lt;&lt; p1.use_count() &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;p1 cnt:&quot; &lt;&lt; p1.use_count() &lt;&lt; endl;    my_shared_ptr&lt;int&gt; p4;    cout &lt;&lt; &quot;p4 cnt: &quot; &lt;&lt; p4.use_count() &lt;&lt; endl;    p4 &#x3D; p1;    cout &lt;&lt; &quot;p1 cnt:&quot; &lt;&lt; p1.use_count() &lt;&lt; &quot; p4 cnt:&quot; &lt;&lt; p4.use_count() &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lru">LRU</h2><h3 id="用stl中list版本">用stl中<code>list</code>版本</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;list&gt;using namespace std;class LRUCache&#123;public:    LRUCache(int capacity): cap_(capacity) &#123;&#125;    int get(int k)&#123;        auto it &#x3D; mp_.find(k);        if(it &#x3D;&#x3D; mp_.end()) return -1;        list_.splice(list_.begin(), list_, it-&gt;second);        return it-&gt;second-&gt;second;    &#125;    void put(int k, int v)&#123;        auto it &#x3D; mp_.find(k);        if(it !&#x3D; mp_.end())&#123;            list_.erase(it-&gt;second);        &#125;        list_.push_front(make_pair(k, v));        mp_[k] &#x3D; list_.begin();        if(mp_.size() &gt; cap_)&#123;            int k &#x3D; list_.rbegin()-&gt;first;            list_.pop_back();            mp_.erase(k);        &#125;    &#125;private:    list&lt;pair&lt;int, int&gt;&gt; list_;    unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator &gt; mp_;    int cap_;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="手写list版本">手写<code>list</code>版本</h3><p>写的时候一定要注意<code>head</code>和<code>tail</code>为空时的边界条件 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;list&gt;using namespace std;struct LRUNode&#123;    int key;    int val;    LRUNode *prev, *next;    LRUNode(int key, int val) : key(key), val(val), prev(nullptr), next(nullptr)&#123;    &#125;&#125;;class LRUCache&#123;public:    LRUCache(int capacity): cap_(capacity), head_(nullptr), tail_(nullptr) &#123;&#125;    int get(int k)&#123;        auto it &#x3D; mp_.find(k);        if(it &#x3D;&#x3D; mp_.end()) return -1;        LRUNode *node &#x3D; it-&gt;second;        remove(node);        insertFront(node);        return node-&gt;val;    &#125;    void put(int k, int v)&#123;        auto it &#x3D; mp_.find(k);        if(it !&#x3D; mp_.end())&#123;            LRUNode *node &#x3D; it-&gt;second;            node-&gt;val &#x3D; v;            remove(node);            insertFront(node);        &#125;else&#123;            LRUNode *node &#x3D; new LRUNode(k, v);            mp_[k] &#x3D; node;            insertFront(node);            if(mp_.size() &gt; cap_)&#123;                mp_.erase(tail_-&gt;key);                removeLast();            &#125;        &#125;    &#125;    void remove(LRUNode *node)&#123;        if(node-&gt;prev) node-&gt;prev-&gt;next &#x3D; node-&gt;next;        else head_ &#x3D; node-&gt;next;        if(node-&gt;next) node-&gt;next-&gt;prev &#x3D; node-&gt;prev;        else tail_ &#x3D; node-&gt;prev;    &#125;    void insertFront(LRUNode *node)&#123;        if(head_ &#x3D;&#x3D; nullptr)&#123;            head_ &#x3D; node;            tail_ &#x3D; node;            return;        &#125;         node-&gt;next &#x3D; head_;        node-&gt;prev &#x3D; nullptr;        head_-&gt;prev &#x3D; node;        head_ &#x3D; node;    &#125;    void removeLast()&#123;        LRUNode *node &#x3D; tail_-&gt;prev;        node-&gt;next &#x3D; nullptr;        delete(tail_);        tail_ &#x3D; node;    &#125;private:    int cap_;    unordered_map&lt;int, LRUNode *&gt; mp_;    LRUNode *head_, *tail_;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ### 智能指针管理资源 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;list&gt;#include &lt;memory&gt;using namespace std;struct LRUNode&#123;    int key;    int val;    shared_ptr&lt;LRUNode&gt; prev, next;    LRUNode(int key, int val) : key(key), val(val), prev(nullptr), next(nullptr)&#123;    &#125;&#125;;class LRUCache&#123;public:    LRUCache(int capacity): cap_(capacity), head_(nullptr), tail_(nullptr) &#123;&#125;    int get(int k)&#123;        auto it &#x3D; mp_.find(k);        if(it &#x3D;&#x3D; mp_.end()) return -1;        shared_ptr&lt;LRUNode&gt;node &#x3D; it-&gt;second;        remove(node);        insertFront(node);        return node-&gt;val;    &#125;    void put(int k, int v)&#123;        auto it &#x3D; mp_.find(k);        if(it !&#x3D; mp_.end())&#123;            shared_ptr&lt;LRUNode&gt;node &#x3D; it-&gt;second;            node-&gt;val &#x3D; v;            remove(node);            insertFront(node);        &#125;else&#123;            shared_ptr&lt;LRUNode&gt; node &#x3D; make_shared&lt;LRUNode&gt;(k, v);            mp_[k] &#x3D; node;            insertFront(node);            if(mp_.size() &gt; cap_)&#123;                mp_.erase(tail_-&gt;key);                removeLast();            &#125;        &#125;    &#125;    void remove(shared_ptr&lt;LRUNode&gt; node)&#123;        if(node-&gt;prev) node-&gt;prev-&gt;next &#x3D; node-&gt;next;        else head_ &#x3D; node-&gt;next;        if(node-&gt;next) node-&gt;next-&gt;prev &#x3D; node-&gt;prev;        else tail_ &#x3D; node-&gt;prev;    &#125;    void insertFront(shared_ptr&lt;LRUNode&gt; node)&#123;        if(head_ &#x3D;&#x3D; nullptr)&#123;            head_ &#x3D; node;            tail_ &#x3D; node;            return;        &#125;         node-&gt;next &#x3D; head_;        node-&gt;prev &#x3D; nullptr;        head_-&gt;prev &#x3D; node;        head_ &#x3D; node;    &#125;    void removeLast()&#123;        shared_ptr&lt;LRUNode&gt; node &#x3D; tail_-&gt;prev;        node-&gt;next &#x3D; nullptr;        tail_ &#x3D; node;    &#125;private:    int cap_;    unordered_map&lt;int, shared_ptr&lt;LRUNode&gt;&gt; mp_;    shared_ptr&lt;LRUNode&gt; head_, tail_;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ## heap 第一个下标从1开始，对于下标为<code>pos</code>的元素，左边元素的下标是<code>2*pos</code>，右边的是<code>2*pos+1</code> <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;template&lt;class T&gt;class MyHeap&#123;public:    MyHeap(int capacity) : cap_(capacity), size_(0) &#123;        h_.resize(cap_);    &#125;    T pop()&#123;        T val &#x3D; h_[1];        h_[1] &#x3D; h_[size_--];        down(1);        return val;    &#125;    void put(T val)&#123;        h_[++size_] &#x3D; val;        up(size_);    &#125;protected:    void up(int pos)&#123;        while(pos&gt;1)&#123;            &#x2F;&#x2F;cout &lt;&lt; &quot;up:&quot; &lt;&lt; pos &lt;&lt; endl;              int parent &#x3D; pos&#x2F;2;            if(h_[pos]&lt;h_[parent])&#123;                swap(h_[pos],h_[parent]);                pos &#x3D; parent;            &#125;else&#123;                break;            &#125;        &#125;    &#125;    void down(int pos)&#123;        while(pos&lt;&#x3D;size_)&#123;            int l_child &#x3D; 2 * pos, r_child &#x3D; 2 * pos + 1;            if(l_child&gt;size_) break;            int min_child &#x3D; (l_child &#x3D;&#x3D; size_ || h_[l_child]&lt;h_[r_child])? l_child : r_child;             if(h_[pos]&gt;h_[min_child])&#123;                swap(h_[pos],h_[min_child]);                pos &#x3D; min_child;            &#125;            else&#123;                break;            &#125;        &#125;    &#125;private:    vector&lt;T&gt; h_;    int cap_;    int size_;&#125;;int main()&#123;    MyHeap&lt;int&gt; h(10);    h.put(10);    h.put(13);    h.put(9);    h.put(20);    cout &lt;&lt; h.pop() &lt;&lt; endl;    cout &lt;&lt; h.pop() &lt;&lt; endl;    cout &lt;&lt; h.pop() &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>libevent库学习笔记</title>
      <link href="/2022/12/20/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/20/libevent%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.wangafu.net/~nickm/libevent-book/01_intro.html">A tiny introduction to asynchronous IO</a></p><h2 id="q阻塞io存在的问题">Q：阻塞I/O存在的问题</h2><p>A：必须前一个读完，才能读下一个。可以采用fork子进程 或者 非阻塞I/O进行</p><h2 id="q非阻塞io运行和存在的问题">Q：非阻塞I/O运行和存在的问题</h2><p>A：通过设置<code>fcntl(fd, F_SETFL, O_NONBLOCK);</code>如果没有数据，会返回<code>EAGAIN</code>，参考代码如下 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* This will work, but the performance will be unforgivably bad. *&#x2F;int i, n;char buf[1024];for (i&#x3D;0; i &lt; n_sockets; ++i)    fcntl(fd[i], F_SETFL, O_NONBLOCK);while (i_still_want_to_read()) &#123;    for (i&#x3D;0; i &lt; n_sockets; ++i) &#123;        n &#x3D; recv(fd[i], buf, sizeof(buf), 0);        if (n &#x3D;&#x3D; 0) &#123;            handle_close(fd[i]);        &#125; else if (n &lt; 0) &#123;            if (errno &#x3D;&#x3D; EAGAIN)                 ; &#x2F;* The kernel didn&#39;t have any data for us to read. *&#x2F;            else                 handle_error(fd[i], errno);         &#125; else &#123;            handle_input(fd[i], buf, n);         &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 这种方式存在两种问题。（1）当任一连接上都没有数据可读时，循环将无限期地旋转，耗尽所有 CPU 周期。（2）如果您尝试使用这种方法处理一个或两个以上的连接，您将对每个连接进行一次内核调用，无论它是否有任何数据供您使用。</p><p>人们仍然使用这个问题的最古老的解决方案是 select()。 select() 调用采用三组 fds（作为位数组实现）：一组用于读取，一组用于写入，一组用于“异常”。它会一直等到其中一个套接字准备就绪，然后将这些套接字更改为仅包含准备好使用的套接字。</p><h2 id="libevent的使用">libevent的使用</h2><h3 id="较底层的使用">较底层的使用</h3><p>callback+状态转移:</p><ul><li>调用event_base_new创建一个event_base对象base</li><li>创建监听fd并设置为非阻塞的</li><li>调用event_new创建事件监听fd是否可读，设置其回调为do_accept，并且在回调时传入base</li><li>调用event_add将上边创建的事件进行注册</li><li>调用event_base_dispatch会循环等待事件发生</li></ul><p><code>do_accept</code>做的事： - 为每个新fd创建一个结构体，维护着相关状态和buffer <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct fd_state &#123;    char buffer[MAX_LINE];    size_t buffer_used;    size_t n_written;    size_t write_upto;    struct event *read_event;    struct event *write_event;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> - 创建可读事件，其回调函数是do_read()，在回调时接收state的指针作为参数 - 创建可写事件，其回调函数是do_write()，同样的，在回调时接收state的指针作为参数 - 将可读事件通过event_add()启动监控</p><p><code>do_read</code>做的事 - 读取到recv返回&lt;=0的结果 - 处理接收到的数据，存入buffer - 调用event_add()将该fd对应的可写监听打开</p><p><code>do_write</code>做的事 - 不断地调用send()发送，直到send返回&lt;=0 - 如果出现EAGAIN就先return</p><h3 id="简化后的使用">简化后的使用</h3><p>处理非阻塞网络IO时，通常都会给每个fd创建对应的buffer缓存，因为一个fd的四种状态<strong>可读-已读完-可写-已写完</strong>之间有一定的时间间隔，而这些间隔内，我们可能因为新的fd可读、可写而去处理新的连接。因此buffer来缓存已读或未写的数据，buffer是必须的。</p><p>简化的版本主要是利用<code>bufferevents</code>库，代码简化从<code>do_accept()</code>开始：</p><ul><li>调用<code>bufferevent_socket_new</code>为每个新<code>fd</code>创建<code>bufferevent</code></li><li>调用<code>bufferevent_setcb</code>对上述<code>bufferevent</code>设置"读"事件回调<code>readcb()</code></li><li>调用<code>bufferevent_enable</code>是事件监控开启</li></ul><p>在<code>readcb()</code>中：</p><ul><li>获取<code>bufferevent</code>的两个<code>buffer</code>，<code>input</code>(读)和<code>output</code>(写)</li><li>调用<code>evbuffer_remove()</code>从<code>input</code>中读 数据处理</li><li>调用<code>evbuffer_add()</code>将返回写入<code>output</code>中</li></ul><h2 id="参考资料">参考资料</h2><p><a href="https://panzhongxian.cn/cn/2020/06/libevent-note-01/">libevent 学习笔记 1 -- 从网络IO说起</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824学习资料整理</title>
      <link href="/2022/12/17/MIT6-824%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
      <url>/2022/12/17/MIT6-824%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="课程部分">课程部分</h2><h3 id="overview">Overview</h3><p>主要是从以下几个部分来介绍： - GFS - VMWARE FT - Raft - Zookeeper - More Replication, CRAQ - Cloud Replicated DB, Aurora - Cache Consistency: Frangipani - Distributed Transaction</p><p><a href="https://csdiy.wiki/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MIT6.824/">简单的课程中文介绍</a></p><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/">翻译版的gitbook</a></p><p><a href="https://www.zhihu.com/question/29597104">如何的才能更好地学习 MIT6.824 分布式系统课程？</a></p><h2 id="实验部分">实验部分</h2><h3 id="实验前必读">实验前必读</h3><p><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">Students' Guide to Raft</a></p><p><a href="http://nil.csail.mit.edu/6.824/2020/labs/raft-locking.txt">Raft Locking Advice</a></p><p><a href="http://nil.csail.mit.edu/6.824/2020/labs/raft-structure.txt">Raft Structure Advice</a></p><p>在分布式系统中如何利用<code>log</code>进行<code>debug</code>:<a href="https://blog.josejg.com/debugging-pretty/">Debugging by Pretty Printing</a></p><p><a href="http://nil.csail.mit.edu/6.824/2020/papers/raft-extended.pdf">Raft 一致性算法论文原文</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5Mjc3MjIyMA==&amp;mid=2247544375&amp;idx=1&amp;sn=0cfa5651969bb136908f2bcaad7ecb2d&amp;source=41#wechat_redirect">Raft 一致性算法论文中文译文</a></p><h3 id="实验介绍">实验介绍</h3><p><a href="https://juejin.cn/post/7121928506476363789">lab 2中文版</a></p><h3 id="他人经验">他人经验</h3><p><a href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021">lab1-lab4的思路分享</a></p><p><a href="https://zhuanlan.zhihu.com/p/464701798">mit6.824 Lab2 总结</a></p><h3 id="其他">其他</h3><h4 id="锁的使用">锁的使用</h4><p>Rule1: 当拥有了超过一个goroutine需要使用的资源，并且至少有一个goroutine会进行更改时，需要加锁，可以使用Go race detector去检测</p><p>Rule2: 当有一系列对共享数据的修改，并且如果中途被打断会造成程序异常时，需要加锁，例如 <pre class="line-numbers language-go" data-language="go"><code class="language-go">rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>rf<span class="token punctuation">.</span>currentTerm <span class="token operator">+=</span> <span class="token number">1</span>rf<span class="token punctuation">.</span>state <span class="token operator">=</span> Candidaterf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre> Rule3: 当进行一系列数据的读取，并且在中途其他goroutine对数据进行修改会造成程序错误时，例如 <pre class="line-numbers language-go" data-language="go"><code class="language-go">rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>Term <span class="token operator">></span> rf<span class="token punctuation">.</span>currentTerm <span class="token punctuation">&#123;</span> rf<span class="token punctuation">.</span>currentTerm <span class="token operator">=</span> args<span class="token punctuation">.</span>Term<span class="token punctuation">&#125;</span>rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre> 如果在第二句和第三句之间，被其他打断，可能会不满足if条件，导致<code>rf.currentTerm</code>被修改为更小的值</p><p>Rule4: 在执行需要wait(reading a Go channel, sending on a channel, waiting for a timer, call time.Sleep())或者send an RPC(and waiting for the reply)的语句之前一定要先释放锁</p><p>Rule5: 小心<code>drop</code>然后<code>re-acquire</code>锁，因为中间被打断可能也会有数据的改变 <pre class="line-numbers language-go" data-language="go"><code class="language-go">rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>rf<span class="token punctuation">.</span>currentTerm <span class="token operator">+=</span> <span class="token number">1</span>rf<span class="token punctuation">.</span>state <span class="token operator">=</span> Candidate<span class="token keyword">for</span> <span class="token operator">&lt;</span>each peer<span class="token operator">></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    args<span class="token punctuation">.</span>Term <span class="token operator">=</span> rf<span class="token punctuation">.</span>currentTerm    rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"Raft.RequestVote"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>args<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token comment">// handle the reply...</span>  <span class="token punctuation">&#125;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 这里<code>goroutine</code>内<code>rf.currentTerm</code>的值和<code>goroutine</code>外面可能会有不同。因此在传入时就应该作为参数，在进行handle reply时，需要检查<code>rf.currentTerm</code>和做决定时是一样的</p><p>简单的编程建议：识别goroutine会开始的所有地方(RPC handlers, 在Make中创建的background goroutines)，在最开始都获取锁，只有在结束的时候才释放锁。之后检查Rule 4: 找到wait的地方，加上lock release和re-acquire。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824——Go&amp;Thread&amp;Raft</title>
      <link href="/2022/12/17/MIT6-824%E2%80%94%E2%80%94Go-Thread-Raft/"/>
      <url>/2022/12/17/MIT6-824%E2%80%94%E2%80%94Go-Thread-Raft/</url>
      
        <content type="html"><![CDATA[<p>这一节课主要对<code>go</code>中会用到的模式进行讲解，感觉和<code>c++</code>多线程编程差不多吧，重点就是知道怎么使用 ## 并发原语 首先是介绍了在<code>go</code>编程中使用的一些模式，同时需要注意的点 ### go loop 经常利用 WaitGroup 来在父 goroutine 中阻塞地等待一组子 goroutine 的完结</p><p>在<code>go func</code>中，会使用外部函数内的变量，此时变量值和外部保持一致，因为最好是采用第二种方法传递进去，否则可能发生错误，因为在运行<code>go func</code>时，外部的<code>i</code>可能已经变了。</p><p><code>WaitGroup</code>的原理为，每次调用<code>wg.Add</code>会增加内部的计数器，<code>wg.Done</code>会减少 1. 当调用 WaitGroup.Add(n) 时，counter 将会自增: counter += n</p><ol start="2" type="1"><li><p>当调用 WaitGroup.Wait() 时，会将 waiter++。同时调用 runtime_Semacquire(semap), 增加信号量，并挂起当前 goroutine。</p></li><li><p>当调用 WaitGroup.Done() 时，将会 counter--。如果自减后的 counter 等于 0，说明 WaitGroup 的等待过程已经结束，则需要调用 runtime_Semrelease 释放信号量，唤醒正在 WaitGroup.Wait 的 goroutine</p></li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go"># closure<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"sync"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> a <span class="token builtin">string</span>    <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        a <span class="token operator">=</span> <span class="token string">"hello world"</span>        wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"># loop<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"sync"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup    <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">&#123;</span>      wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token function">sendRPC</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>          wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">sendRPC</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定期做某事">定期做某事</h3><p>如何控制 - 定期做：<code>for loop + sleep</code> - 结束控制：<code>done变量 + lock控制并发访问</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"># sleep<span class="token operator">-</span>cancel<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"sync"</span><span class="token keyword">import</span> <span class="token string">"time"</span><span class="token keyword">var</span> done <span class="token builtin">bool</span><span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"started"</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">periodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    done <span class="token operator">=</span> <span class="token boolean">true</span>    mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"cancelled"</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">periodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"tick"</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> done<span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>        <span class="token punctuation">&#125;</span>        mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说到锁，一个很常用的模式就是<code>defer</code>的使用，其实就等价于把该语句放在函数题的结尾，避免忘记 <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  counter <span class="token operator">=</span> counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>等价于<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  counter <span class="token operator">=</span> counter <span class="token operator">+</span> <span class="token number">1</span>  mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ### 条件变量 定义：<code>cond := sync.NewCond(&amp;mu)</code></p><p>和条件变量相关的操作是<code>wait/broadcast/signal</code></p><p><code>cond.Signal</code> 每次仅唤起一个调用 <code>cond.Wait</code> 进入等待的线程，而 <code>cond.Broadcast</code> 会唤起所有等待在相应锁上的线程。</p><p><strong>需要注意的是：在使用时都应该放到lock内，在<code>cond.Signal</code>和<code>cond.Broadcast</code>使用完后需要释放锁</strong></p><p>给出一个Candidate 向所有 Followers 要票场景的例子 <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    count <span class="token operator">:=</span> <span class="token number">0</span>    finished <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex    cond <span class="token operator">:=</span> sync<span class="token punctuation">.</span><span class="token function">NewCond</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mu<span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">&#123;</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        vote <span class="token operator">:=</span> <span class="token function">requestVote</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> vote<span class="token punctuation">&#123;</span>            count <span class="token operator">++</span>            <span class="token punctuation">&#125;</span>            finished <span class="token operator">++</span>            cond<span class="token punctuation">.</span><span class="token function">BroadCast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> count <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> finished <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">&#123;</span>    cond<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> count <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"received 5+ votes!"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lost"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    mu<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 经过这些例子，观察到一个重要的点是<strong>加锁的粒度</strong>，感觉可以从事务的原子性去类比考虑，哪些操作不能被打断，否则可能会带来race</p><h3 id="通道">通道</h3><p>无buffer的channels没有内部存储，作为一种<strong>同步通讯机制</strong>，当有人需要发送，有人需要接受，才会happen，否则会阻塞</p><p>适用于 - 生产者消费者模型(buffered channel) - <code>WaitGroup</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">sendRPC</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>done <span class="token operator">&lt;-</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token operator">&lt;-</span>done<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">sendRPC</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料">参考资料</h2><p><a href="https://juejin.cn/post/7064220978825560072">MIT 6.824 视频笔记五：Go Concurrency</a></p><p><a href="https://www.bilibili.com/video/BV1CU4y1P7PE?p=5&amp;vd_source=b2dfa40e00786129d946ba9ac4634819">MIT 6.824 Lecture 5</a></p><p><a href="https://zhuanlan.zhihu.com/p/344973865">Golang WaitGroup 原理深度剖析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程之美阅读笔记（一）</title>
      <link href="/2022/12/17/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/17/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>一直看到各路博主安利这门书，在家里的书柜里把之前买了一直没看的这本书又翻了出来。读这本书的感受大概是——很有意思的算法题......于是将有意思的题记录下来</p><h2 id="第一章-游戏之乐">第一章 游戏之乐</h2><h3 id="将帅问题">将帅问题</h3><p>中国象棋中的将帅不能碰面，假设A为将，B为帅，则A,B分别只能在己方3*3的格子里面运动，且不能碰面，请书写一个程序，输出A，B所有的合法位置，要求代码中只能用一个字节存储变量。 #### 解法一 分析：题目的关键是<strong>一个字节</strong>存储，自然的想到用<strong>bit</strong>去存储位置，加上枚举就能得到结果。思路很简单，但是答案让我非常impressive的一点是<strong>简洁的<code>define</code>用法</strong> <del>虽然貌似在effective c++中不推荐使用define</del></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#define HALF_BITS_LENGTH 4#define FULLMASK 255#define RMASK (FULLMASK &gt;&gt; HALF_BITS_LENGTH)#define LMASK (FULLMASK &lt;&lt; HALF_BITS_LENGTH)#define LSET(b, n) (b&#x3D;((b&amp;RMASK)|(n&lt;&lt;HALF_BITS_LENGTH)))#define RSET(b, n) (b&#x3D;((b&amp;LMASK)|n))#define RGET(b) (b&amp;RMASK)#define LGET(b) ((b&amp;LMASK)&gt;&gt;HALF_BITS_LENGTH)#define MAXPOS 9int main()&#123;unsigned char b;    for(LSET(b,1); LGET(b)&lt;&#x3D;MAXPOS; LSET(b, LGET(b)+1))    &#123;    for(RSET(b,1); RGET(b)&lt;&#x3D;MAXPOS; RSET(b, RGET(b)+1))&#123;        if(LGET(b)%3!&#x3D;RGET(b)%3) printf(&quot;A&#x3D;%d, B&#x3D;%d\n&quot;, LGET(b), RGET(b));        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解法二">解法二</h4><p>刚刚是我们的标准解法，之后给出了其他的解法，首先看和标准解法最相近的第一种 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct&#123;unsigned char a:4;    unsigned char b:4;&#125;i;for(i.a&#x3D;1; i.a&lt;&#x3D;9; i.a++)&#123;for(i.b&#x3D;0; i.b&lt;&#x3D;9; i.b++)&#123;    if(i.a%3!&#x3D;i.b%3) printf(...);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 这里用到了<strong>位域</strong>，有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态，用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。 #### 解法三 最后一种解法的思路在想既然我们一共有<code>9*9</code>种位置的组合情况，我们需要的<code>pos1</code>和<code>pos2</code>要没有依赖关系，也就是在<code>pos1=x</code>时，<code>pos2</code>可以对所有值进行遍历，这个时候想到了除数，余数，其中一个取除数另一个取余数，这样就能遍历所有值了。 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(i&#x3D;1; i&lt;&#x3D;81; ++i)&#123;if(i%9%3 !&#x3D; i&#x2F;9%3) printf(...);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre> #### 到底哪种更快 对解法1～3进行测试，结果如下 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">解法一：time is 0.000130解法二：time is 0.000091解法三：time is 0.000081<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre> 由此可见，解法3是最快的，真的是毫无多余操作惹</p><h3 id="如何找出故障的机器">如何找出故障的机器</h3><p>题目：假设一个机器只存储一个标号为ID的记录，假设每份数据保存2个备份，这样就有2个机器存储了相同的数据。其中ID是小于10亿的整数</p><p>问题1、在某个时间，如果得到一个数据文件ID的列表。是否能够快速的找到这个表中仅出现一次的ID?即快速找出出现故障的机器存储的数据ID。</p><p>问题2、如果有两台机器死机呢？（假设同一个数据的俩个备份不会同时丢失，即列表中缺少的是两个不等的ID）</p><p>扩展题、如果所有的机子都有三个备份，也就是说同一ID的机子有三台。而且同时又有三台机子死机，还能用上面的方法解决吗？</p><p>如果有N台备份，又同时有N台机器死机呢？</p><p><strong>分析</strong>：已知一个数组，数组中只有<code>n</code>个数据是出现一遍的，其他数据都是出现两遍，我们要把这个数据找出来</p><p>给我最具有启发性idea是： - 异或操作：寻找一个函数<code>f</code>能将映射到要找的值中 - 不变量：有什么是不变的，哪些变化会带来这个不变量的变化</p><h4 id="解法一">解法一</h4><p>如果只有一台不同的机器，直接<code>异或</code>操作，最后就是结果啦！</p><p>但是当不同的机器上升为两台时，异或操作的结果就是这两台机器的异或值，如果有不同的位，可以分类讨论，直接安装这一位把原来的机器分为两类。</p><p>但是当机器数上升时，这个方法就不能用了。。。</p><h4 id="解法二-1">解法二</h4><p>求和是一个不变量，因为可以直接求和，坏掉机器的id和=原来的总和-现在的总和</p><p>在坏掉多台时，显然一个方程解不出来，那可以再加方程进入，例如平方和、乘积等等。这个就有了多个方程求解多个未知数了</p><p>思考了一下下，发现需要注意的点就是，加入的方程需要满足<strong>对称性</strong>，和已有式子的不相关性。 （虽然觉得在多台情况比较复杂时，可能采用计数+达到数量不存储可以更简单）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824——GFS文件系统</title>
      <link href="/2022/12/15/MIT6-824%E2%80%94%E2%80%94GFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/15/MIT6-824%E2%80%94%E2%80%94GFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统gfs文件系统">分布式系统——GFS文件系统</h1><p>参考论文: https://pdos.csail.mit.edu/6.824/papers/gfs.pdf</p><p><img src="http://rn0ze8mqu.hn-bkt.clouddn.com/pasted-0.png" /></p><p><img src="http://rn0ze8mqu.hn-bkt.clouddn.com/pasted-1.png" /></p><p><img src="http://rn0ze8mqu.hn-bkt.clouddn.com/pasted-2.png" /></p><p><img src="http://rn0ze8mqu.hn-bkt.clouddn.com/pasted-3.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824——Primary-Backup Replication</title>
      <link href="/2022/12/15/MIT6-824%E2%80%94%E2%80%94Primary-Backup-Replication/"/>
      <url>/2022/12/15/MIT6-824%E2%80%94%E2%80%94Primary-Backup-Replication/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1CU4y1P7PE?p=4&amp;vd_source=b2dfa40e00786129d946ba9ac4634819">课程链接</a></p><p>主从备份可以工作的前提是：主从机器出错的概率是相互独立的 ## 主从备份</p><h3 id="同步状态的级别">同步状态的级别</h3><ul><li><p>应用层</p><p>GFS采取的是应用层的同步</p></li><li><p>机器层</p><p>运行的服务器无需改动而获取容错能力，但需要更细粒度的同步，例如中断DMA</p></li></ul><h3 id="两种备份的方式">两种备份的方式</h3><ul><li><p>State transfer(状态转移)</p><p>持续增量同步Primary的状态到Backup，包括CPU、内存等，同步时需要占用较大带宽</p></li><li><p>Replicated State Machine（冗余状态机）</p><p>同步的是外部事件/操作/输入，但是一些事件，例如随机数的生成，是不具有确定性的</p></li></ul><h3 id="backup过程">backup过程</h3><p>virtual machine monitor可以感知到client发送的中断等信号，将这些信号转发到backup virtual machine monitor上。只有primary能生成数据回复，backup会drop掉恢复的包</p><p>primary和back会通过logging channel进行通信，如果发现找不到primary，就成为primary, 具体切换过程如下： - Backup声称具有primary的mac地址，让ARP缓存表过期，这样IP的流量就会到Backup - 切换后Backup成为新的primary</p><p>Non-deterministic events</p><ul><li>Inputs-&gt;packet-&gt;data+interrupt:在哪条指令之间发生中断必须相同</li><li>weird instructions：随机数生成器</li><li>multi-core</li></ul><h3 id="logging-channel">logging channel</h3><p>为了进行容错（FT），我们使用日志条目（log entry ）来记录 Primary 上发生的事件；但我们并没有将这些日志写到硬盘中，而是将其通过日志通道（logging channel）传送到 Backup 上进行实时确定性的重建（deterministic replay），其包含 - instruction number: to handle interruption - type: to record weird instructions - data</p><h3 id="output-rule">OutPut rule</h3><p>用来保证指令primary如果发生宕机，发送给Backup的指令丢失带来的不一致性。 核心就是：等待收到 Backup 该条指令的 ACK 时，才会将该指令结果发送给用户。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebserver源码阅读（三）</title>
      <link href="/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在第三部分，主要对日志系统<code>log</code>和定时器<code>timer</code>进行分析 ## 1 日志<code>log</code> <code>log</code>部分由三部分组成，<code>blockqueue.h</code>, <code>log.h</code>, <code>log.cpp</code>，<code>blockqueue</code>是封装的类似<code>deque</code>的能进行并发访问和操作的底层结构，<code>log.cpp</code>实现了日志的功能 ### 1.1 <code>blockqueue</code>的实现 #### 1.1.1 成员变量和方法分析 <code>blockqueue</code>和<code>deque</code>的功能是类似的，主要是在<code>deque</code>上加了一层并发访问的控制，其调用接口包括了<code>empty()</code>, <code>full()</code>, <code>Close()</code>, <code>size()</code>, <code>capacity()</code>, <code>front()</code>, <code>back()</code>, <code>push_back(const T &amp;item)</code>, <code>push_front(const T &amp;item)</code>, 稍有区别的为 - <code>bool pop(T &amp;item)</code>: 如果<code>isClose_</code>为<code>true</code>返回<code>false</code>，否则返回<code>true</code>，首个元素会被放在<code>item</code>中 - <code>bool pop(T &amp;item, int timeout)</code>: 如果<code>isClose_</code>为<code>true</code>或者在<code>timeout</code>时间内没有返回，返回<code>false</code></p><p>对成员变量进行分析，包括 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::deque&lt;T&gt; deq_; &#x2F;&#x2F; deque双端队列size_t capacity_; &#x2F;&#x2F; 容量std::mutex mtx_; &#x2F;&#x2F;锁mutexbool isClose_; &#x2F;&#x2F;是否关闭std::condition_variable condConsumer_; &#x2F;&#x2F; 生产者信号量std::condition_variable condProducer_; &#x2F;&#x2F; 消费者信号量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 从成员变量中，可以猜测出使用的是生产者消费者模型，生成者向<code>deq_</code>中添加元素，消费者从<code>deq_</code>中取出元素</p><h4 id="元素的访问">1.1.2 元素的访问</h4><p>元素的访问不涉及到对<code>deq_</code>的操作，因为在访问之前只用获取<code>mtx_</code>的锁然后去访问元素就行，下面给出<code>back</code>和<code>empty</code>的例子</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class T&gt;T BlockQueue&lt;T&gt;::back()&#123;std::lock_guard&lt;std::mutex&gt; locker(mtx_):return deq_.back();&#125;template&lt;class T&gt;bool BlockQueue&lt;T&gt;::empty()&#123;std::lock_guard&lt;std::mutex&gt; locker(mtx_);return deq_.empty();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里<code>lock_guard</code>在初始化的时候，可以自动获取锁</p><h4 id="元素的操作">1.1.4 元素的操作</h4><p>在涉及对元素的操作时，情况就稍稍复杂一点点，这时候不仅要考虑并发读，也要考虑并发写，还需要考虑<code>deq_</code>为空的情况。这里主要用两个操作进行举例，<code>push_back</code>和<code>pop</code> <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class T&gt;void BlockQueue::push_back(const T &amp;item)&#123;std::lock_guard&lt;std::mutex&gt; locker(mtx_);&#123;while(deq_.size()&gt;&#x3D;Capacity())&#123;condProducer_.wait(locker);&#125;deq_.push_back(item);condConsumer_.notify_one();&#125;&#125;template&lt;class T&gt;bool BlockQueue::pop(T &amp;item)&#123;std::lock_guard&lt;std::mutex&gt; locker(mtx_);while(deq_.empty())&#123;condConsumer_.wait(locker);if(isClose_)&#123;return false;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="初始化和关闭">1.1.5 初始化和关闭</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class T&gt;BlockDeque&lt;T&gt;::BlockDeque(size_t MaxCapacity) :capacity_(MaxCapacity) &#123;    assert(MaxCapacity &gt; 0);    isClose_ &#x3D; false;&#125;template&lt;class T&gt;void BlockDeque&lt;T&gt;::Close() &#123;    &#123;           std::lock_guard&lt;std::mutex&gt; locker(mtx_);        deq_.clear();        isClose_ &#x3D; true;    &#125;    condProducer_.notify_all();    condConsumer_.notify_all();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化的时候主要是去初始化了<code>capability_</code>，并设置<code>isClose_</code>为<code>false</code>，在关闭时把<code>isClose_</code>设置为<code>true</code>，并用信号量<code>condProducer_</code>和<code>condCustomer_</code>通知阻塞的线程。注意<code>isClose_</code>变量是为了告诉其他线程，它需要结束了，这样在<code>pop</code>的时候会返回<code>false</code></p><h2 id="log的实现">1.2 <code>log</code>的实现</h2><p><code>log</code>采用的也是单例模式 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static Log* instance();Log* Log::instance()&#123;static Log log;return &amp;log;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre> <code>log</code>的成员变量包括 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const char* path_; &#x2F;&#x2F; 路径const char* suffix_; &#x2F;&#x2F; 后缀int MAX_LINES_; &#x2F;&#x2F; 最大行数int lineCount_; &#x2F;&#x2F; 目前的行数int toDay_; &#x2F;&#x2F; 是多少号 tm.tm_mdaybool isOpen_; &#x2F;&#x2F; 是否打开 Buffer buff_; &#x2F;&#x2F; 缓冲区int level_; &#x2F;&#x2F; 日志级别bool isAsync_; &#x2F;&#x2F; 是否异步FILE* fp_; &#x2F;&#x2F; 文件指针std::unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; deque_; &#x2F;&#x2F; blockQueue队列std::unique_ptr&lt;std::thread&gt; writeThread_; &#x2F;&#x2F; 写日志的线程std::mutex mtx_; &#x2F;&#x2F; 锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ### 1.2.1 <code>init</code>方法 在<code>init</code>方法中，会初始化日志级别<code>level</code>，路径<code>path</code>，后缀<code>suffix</code>，缓冲区的最大长度<code>maxQueueSize</code>，它做了以下事情 - 初始化<code>deque_</code>和<code>writeThread_</code> - 新的<code>thread</code>采用<code>new thread(FlushLogThread)</code>,<code>FlushLogThread</code>是一个静态方法，它获得<code>Log::instance</code>并调用其<code>AsyncWrite_</code>将<code>deque_</code>的内容写出。 - 创建<code>log</code>文件，在此前检查<code>fp_</code>有没有被打开，如果被打开先把内容写回。该操作涉及到临界区资源，因此需要申请锁 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Log::init(int level &#x3D; 1, const char* path, const char* suffix, int maxQueueSize) &#123;    isOpen_ &#x3D; true;    level_ &#x3D; level;    if(maxQueueSize &gt; 0) &#123;        isAsync_ &#x3D; true;        if(!deque_) &#123;            unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; newDeque(new BlockDeque&lt;std::string&gt;);            deque_ &#x3D; move(newDeque);            std::unique_ptr&lt;std::thread&gt; NewThread(new thread(FlushLogThread));            writeThread_ &#x3D; move(NewThread);        &#125;    &#125; else &#123;        isAsync_ &#x3D; false;    &#125;    lineCount_ &#x3D; 0;    time_t timer &#x3D; time(nullptr);    struct tm *sysTime &#x3D; localtime(&amp;timer);    struct tm t &#x3D; *sysTime;    path_ &#x3D; path;    suffix_ &#x3D; suffix;    char fileName[LOG_NAME_LEN] &#x3D; &#123;0&#125;;    snprintf(fileName, LOG_NAME_LEN - 1, &quot;%s&#x2F;%04d_%02d_%02d%s&quot;,             path_, t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, suffix_);    toDay_ &#x3D; t.tm_mday;    &#123;        lock_guard&lt;mutex&gt; locker(mtx_);        buff_.RetrieveAll();        if(fp_) &#123;             flush();            fclose(fp_);         &#125;        fp_ &#x3D; fopen(fileName, &quot;a&quot;);        if(fp_ &#x3D;&#x3D; nullptr) &#123;            mkdir(path_, 0777);            fp_ &#x3D; fopen(fileName, &quot;a&quot;);        &#125;         assert(fp_ !&#x3D; nullptr);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="log_base方法">1.2.2 <code>LOG_BASE</code>方法</h3><p>在实际使用中，我们采用的是<code>LOG_INFO</code>, <code>LOG_WARN</code>等方法，其定义如下： <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LOG_DEBUG(format, ...) do &#123;LOG_BASE(0, format, ##__VA_ARGS__)&#125; while(0);#define LOG_INFO(format, ...) do &#123;LOG_BASE(1, format, ##__VA_ARGS__)&#125; while(0);#define LOG_WARN(format, ...) do &#123;LOG_BASE(2, format, ##__VA_ARGS__)&#125; while(0);#define LOG_ERROR(format, ...) do &#123;LOG_BASE(3, format, ##__VA_ARGS__)&#125; while(0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre> 它们底层都利用的是<code>LOG_BASE</code>方法，只是设置了不同的日志级别<code>level</code>，那<code>LOG_BASE</code>又做了什么事呢？下面针对代码进行分析 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LOG_BASE(level, format, ...) \    do &#123;\        Log* log &#x3D; Log::Instance();\        if (log-&gt;IsOpen() &amp;&amp; log-&gt;GetLevel() &lt;&#x3D; level) &#123;\            log-&gt;write(level, format, ##__VA_ARGS__); \            log-&gt;flush();\        &#125;\    &#125; while(0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 这里涉及到一个使用<a href="https://www.jianshu.com/p/4ac2195ea9b6">do_while(0)</a>，该操作是为了在<code>define</code>宏中封装较为复杂的代码。 - 首先调用<code>Log::instance()</code>获取<code>log</code> - 如果<code>log</code>打开并且日志等级小于<code>level</code>，表示需要写入日志，调用<code>log-&gt;write</code>和<code>log-&gt;flush</code></p><h3 id="write方法">1.2.3 <code>write</code>方法</h3><p><code>write</code>做的事情如下： - 判断打开的日志是否写满 or 日期是否和现在日期相等，如果写满了或者日期不相等，把已有内容用<code>flush</code>写回，创建一个新的<code>fp_</code>（在此期间因为涉及到对<code>buff_</code>和<code>fp_</code>的操作，需要<code>locker</code>） - 向<code>buffer_</code>中写入日期，写入<code>log level title</code>，写入传入的参数 - 如果是异步操作，把<code>buffer</code>中的内容放到<code>deque_</code>中，否则直接<code>fputs</code>，调用<code>buff_.retrieveAll()</code>表示所有的内容都已写，改变其<code>readPos_</code> - <code>flush</code>操作，会调用<code>deque_-&gt;flush()</code>去<code>notify_one</code>一个线程，并且会用<code>fflush(fp_)</code>去将缓冲区的内容写回。</p><h2 id="timer分析">2 <code>timer</code>分析</h2><h3 id="timernode分析">2.1 <code>timerNode</code>分析</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef std::function&lt;void()&gt; TimeoutCallBack;typedef std::chrono::high_resolution_clock Clock;typedef std::chrono::milliseconds MS;typedef Clock::time_point TimeStamp;struct TimerNode &#123;    int id;    TimeStamp expires;    TimeoutCallBack cb;    bool operator&lt;(const TimerNode&amp; t) &#123;        return expires &lt; t.expires;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>TimerNode</code>有三个属性，<code>id</code>，<code>expire</code>到期时间，<code>timeoutCallBack</code>在时间到期后的回调函数，其重载了<code>operator &lt;</code>按照<code>expire</code>进行比较</p><h3 id="heaptimer">2.2 <code>HeapTimer</code></h3><p><code>heapTimer</code>自定义 其成员变量有两个 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::vector&lt;TimerNode&gt; heap_;std::unordered_map&lt;int, size_t&gt; ref_;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre> <code>heap_</code>用来存储<code>TimerNode</code> #### 2.2.1 堆的构建 参考<code>STL</code>中堆的构建方法， 首先看<code>siftup_</code>代码： <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HeapTimer::siftup_(size_t i)&#123;assert(i&gt;&#x3D;0 &amp;&amp; i&lt;heap.size());size_t j &#x3D; (i-1)&#x2F;2; &#x2F;&#x2F;找到父节点while(j&gt;&#x3D;0)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webserver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebserver源码阅读（二）</title>
      <link href="/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要介绍<code>Http</code>和<code>Buffer</code>部分 <code>Http</code>请求和响应部分，其主要包含三个类<code>httpConn</code>, <code>httpRequest</code>, <code>httpResponse</code> <code>Buffer</code>解决的是并发情况下的读写问题 ## 1. http请求和响应报文 首先让我们熟悉一下请求（Request）和响应（Response）报文，这两种报文在<code>WebServer</code>服务器中分别对应<code>httpRequest</code>和<code>httpResponse</code>类进行处理。 ### 1.1 http请求报文 HTTP请求报文由四部分组成： - 请求行 - 请求头部 - 空行 - 请求数据</p><p>请求分为两种，GET和POST，让我们来看一个例子 GET <pre class="line-numbers language-http" data-language="http"><code class="language-http">（请求行部分）<span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=</span> <span class="token http-version property">HTTP/1.1</span></span>  （请求头部分）<span class="token header"><span class="token header-name keyword">Accept</span><span class="token punctuation">:</span> <span class="token header-value">image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, application/x-silverlight, application/x-shockwave-flash, */*  </span></span><span class="token header"><span class="token header-name keyword">Referer</span><span class="token punctuation">:</span> <span class="token header-value">&lt;a href="http://www.google.cn/">http://www.google.cn/&lt;/a>  </span></span><span class="token header"><span class="token header-name keyword">Accept-Language</span><span class="token punctuation">:</span> <span class="token header-value">zh-cn  </span></span><span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">gzip, deflate  </span></span><span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span> <span class="token header-value">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  </span></span><span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">&lt;a href="http://www.google.cn">www.google.cn&lt;/a>  </span></span><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">Keep-Alive  </span></span><span class="token header"><span class="token header-name keyword">Cookie</span><span class="token punctuation">:</span> <span class="token header-value">PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r</span></span>（空行）（请求数据）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> POST <pre class="line-numbers language-http" data-language="http"><code class="language-http">POST / HTTP1.1<span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span><span class="token header-value">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span></span><span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span><span class="token header-value">application/x-www-form-urlencoded</span></span><span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span><span class="token header-value">40</span></span><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">Keep-Alive</span></span>空行name=Professional%20Ajax&amp;publisher=Wiley<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ### 1.2 http响应报文 http响应报文由四部分组成 - 状态行 - 消息报头 - 空行 - 响应正文 一个例子如下 <pre class="line-numbers language-http" data-language="http"><code class="language-http">（状态行）<span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span>（消息报头）<span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Sat, 31 Dec 2005 23:59:59 GMT</span></span><span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html;charset=ISO-8859-1</span></span><span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">122</span></span>（空行）（响应正文）＜html＞＜head＞＜title＞Wrox Homepage＜/title＞＜/head＞＜body＞＜!-- body goes here --＞＜/body＞＜/html＞<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ## 2 <code>httpConn</code>类 <code>httpConn</code>类处理的是和<code>http</code>连接相关的问题，它用于处理和<code>client</code>的连接 其成员变量有 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static bool isET; &#x2F;&#x2F; 是否是边缘触发static const char* srcDir; &#x2F;&#x2F;根路径static std::atomic&lt;int&gt; userCount; &#x2F;&#x2F;总用户数int fd_; &#x2F;&#x2F;文件描述符struct  sockaddr_in addr_; &#x2F;&#x2F;连接时的socket地址bool isClose_; &#x2F;&#x2F;是否关闭int iovCnt_; &#x2F;&#x2F;供readv&#x2F;writev使用，表示缓冲区的个数struct iovec iov_[2]; &#x2F;&#x2F;供readv&#x2F;writev使用，表示缓冲区地址(iov_base)和长度(iov_len)的结构体Buffer readBuff_; &#x2F;&#x2F; 读缓冲区Buffer writeBuff_; &#x2F;&#x2F; 写缓冲区HttpRequest request_; &#x2F;&#x2F; httpRequest对象HttpResponse response_; &#x2F;&#x2F; httpResponse对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 从成员变量中就可以看出，<code>httpConn</code>就是<code>http</code>连接的一个表示，因为成员函数就显而易见了 - <code>init/close</code>: 初始化<code>httpConn</code>和关闭文件 - <code>read/write</code>:读取数据到<code>readBuff</code>中/将<code>writeBuff</code>中写出 - <code>process</code>: 解析<code>readBuff</code>，将相应的<code>response</code>写到<code>writeBuff</code> - <code>IsKeepAlive</code>: 是否还保持连接，通过<code>request_</code>的<code>isKeepAlive</code>进行判断 - <code>get</code>相关的方法: 获得地址/端口号等等 ### 2.1 <code>init</code>和<code>close</code> <code>init</code>: 初始化成员变量和静态变量，例如<code>userCount++</code>,设置<code>fd</code>, <code>addr</code>，初始化<code>writeBuff</code>和<code>readBuff</code>等等 <code>close</code>: 解除<code>response_</code>建立的文件映射，<code>userCount--</code>,关闭<code>fd</code>，设置<code>isClosed</code>，在析构函数中会调用<code>close</code> ### 2.2 <code>read</code> <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t HttpConn::read(int* saveErrno) &#123;    ssize_t len &#x3D; -1;    do &#123;        len &#x3D; readBuff_.ReadFd(fd_, saveErrno);        if (len &lt;&#x3D; 0) &#123;            break;        &#125;    &#125; while (isET);    return len;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ### 2.3 <code>write</code> 当<code>fd</code>注册<code>EPOLLIN</code>事件时，当TCP读缓冲区有数据到达时就会触发<code>EPOLLIN</code>事件。当<code>fd</code>注册<code>EPOLLOUT</code>事件时，当TCP写缓冲区有剩余空间时就会触发<code>EPOLLOUT</code>事件，此时<code>DealWrite</code>就是处理<code>EPOLLOUT</code>事件。 这里有一个问题是，为什么要放到循环中? &gt;查看<code>writev</code>的用法有提到 &gt; When using non-blocking I/O on objects, such as sockets, that are subject to flow control, write() and writev() may write fewer bytes than requested; the return value must be noted, and the remainder of the operation should be retried when possible</p><p><code>writev</code>是分散写,也就是你的数据可以这里一块,那里一块,然后只要将这些数据的首地址,长度什么的写到一个<code>iovc</code>的结构体数组里,传递给<code>writev</code>,<code>writev</code>就帮你来写这些数据,在你看来,分散的数据就像是连成了一体。但是在非阻塞IO的情况下，如果writev返回一个大于0的值num,这个值又小于所有要传递的文件块的总长度,这意味着什么,意味着数据还没有写完。如果你还想写的话,你下一次调用writev的时候要重新整理iovc数组</p><pre class="line-numbers language-none"><code class="language-none">ssize_t HttpConn::write(int* saveErrno) &#123;    ssize_t len &#x3D; -1;    do &#123;        len &#x3D; writev(fd_, iov_, iovCnt_);        if(len &lt;&#x3D; 0) &#123;            *saveErrno &#x3D; errno;            break;        &#125;        if(iov_[0].iov_len + iov_[1].iov_len  &#x3D;&#x3D; 0) &#123; break; &#125; &#x2F;* 传输结束 *&#x2F;        else if(static_cast&lt;size_t&gt;(len) &gt; iov_[0].iov_len) &#123;            iov_[1].iov_base &#x3D; (uint8_t*) iov_[1].iov_base + (len - iov_[0].iov_len);            iov_[1].iov_len -&#x3D; (len - iov_[0].iov_len);            if(iov_[0].iov_len) &#123;                writeBuff_.RetrieveAll();                iov_[0].iov_len &#x3D; 0;            &#125;        &#125;        else &#123;            iov_[0].iov_base &#x3D; (uint8_t*)iov_[0].iov_base + len;             iov_[0].iov_len -&#x3D; len;             writeBuff_.Retrieve(len);        &#125;    &#125; while(isET || ToWriteBytes() &gt; 10240);    return len;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="process函数">2.4 <code>process</code>函数</h3><ul><li>初始化<code>request_</code>: <code>request_.init()</code></li><li>解析<code>readBuff_</code>: <code>request.parse(readBuff_)</code>,同时用解析的内容初始化<code>response_</code></li><li>生成回应内容: <code>response_.makeResponse()</code></li><li>更新<code>iov</code>和<code>iov_cnt</code>: <code>iov[0]</code>存储的是响应头，<code>iov[1]</code>存储的是响应文件<code>response_.File()</code></li></ul><h2 id="httprequest类">3 <code>httpRequest</code>类</h2><p>我们仍旧从成员变量开始分析 <pre class="line-numbers language-none"><code class="language-none">PARSE_STATE state_; &#x2F;&#x2F; 状态std::string method_, path_, version_, body_; &#x2F;&#x2F;方法，路径，版本，请求体std::unordered_map&lt;std::string, std::string&gt; header_; &#x2F;&#x2F;请求头std::unordered_map&lt;std::string, std::string&gt; post_; &#x2F;&#x2F;post的内容static const std::unordered_set&lt;std::string&gt; DEFAULT_HTML;static const std::unordered_map&lt;std::string, int&gt; DEFAULT_HTML_TAG;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 可以看出<code>httpRequest</code>是对<code>socket</code>解析到的<code>http</code>状态的解析和保存。最主要的是<code>parse</code>函数，剩下的就约等于字符串的处理，将处理的字符串保存在成员变量中。 ### 3.1 <code>parse</code>函数 其利用有限状态机模型，每次解析一行，从已知状态跳转到下一个状态，可以参考1.1中的<code>http</code>请求报文 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> bool HttpRequest::parse(Buffer&amp; buff) &#123;    const char CRLF[] &#x3D; &quot;\r\n&quot;;    if(buff.ReadableBytes() &lt;&#x3D; 0) &#123;        return false;    &#125;    while(buff.ReadableBytes() &amp;&amp; state_ !&#x3D; FINISH) &#123;        const char* lineEnd &#x3D; search(buff.Peek(), buff.BeginWriteConst(), CRLF, CRLF + 2);        std::string line(buff.Peek(), lineEnd);        switch(state_)        &#123;        case REQUEST_LINE:            if(!ParseRequestLine_(line)) &#123;                return false;            &#125;            ParsePath_(); &#x2F;&#x2F; state在其中会被置为HEADERS            break;            case HEADERS:            ParseHeader_(line); &#x2F;&#x2F; state被置为BODY            if(buff.ReadableBytes() &lt;&#x3D; 2) &#123;                state_ &#x3D; FINISH;            &#125;            break;        case BODY:            ParseBody_(line);            break;        default:            break;        &#125;        if(lineEnd &#x3D;&#x3D; buff.BeginWrite()) &#123; break; &#125;        buff.RetrieveUntil(lineEnd + 2);    &#125;    LOG_DEBUG(&quot;[%s], [%s], [%s]&quot;, method_.c_str(), path_.c_str(), version_.c_str());    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ### 3.2 <code>parseHeader</code> 直接采用<code>regex</code>字符串匹配，将陪陪的字符串保存在<code>header</code>中 <pre class="line-numbers language-none"><code class="language-none">void HttpRequest::ParseHeader_(const string&amp; line) &#123;    regex patten(&quot;^([^:]*): ?(.*)$&quot;);    smatch subMatch;    if(regex_match(line, subMatch, patten)) &#123;        header_[subMatch[1]] &#x3D; subMatch[2];    &#125;    else &#123;        state_ &#x3D; BODY;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ## 4 <code>httpResponse</code>类 成员变量如下 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int code_; &#x2F;&#x2F; status codebool isKeepAlive_;std::string path_;std::string srcDir_;char* mmFile_; &#x2F;&#x2F;struct stat mmFileStat_;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ### 4.1 <code>init</code> 采用<code>response_.parse()</code>获得的<code>src</code>, <code>path</code>, <code>code</code>, <code>keepalive</code>进行初始化 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HttpResponse::Init(const string&amp; srcDir, string&amp; path, bool isKeepAlive, int code)&#123;    assert(srcDir !&#x3D; &quot;&quot;);    if(mmFile_) &#123; UnmapFile(); &#125;    code_ &#x3D; code;    isKeepAlive_ &#x3D; isKeepAlive;    path_ &#x3D; path;    srcDir_ &#x3D; srcDir;    mmFile_ &#x3D; nullptr;     mmFileStat_ &#x3D; &#123; 0 &#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="makeresponse">4.2 <code>makeResponse</code></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HttpResponse::MakeResponse(Buffer&amp; buff) &#123;    &#x2F;* 判断请求的资源文件 *&#x2F;    if(stat((srcDir_ + path_).data(), &amp;mmFileStat_) &lt; 0 || S_ISDIR(mmFileStat_.st_mode)) &#123;        code_ &#x3D; 404;    &#125;    else if(!(mmFileStat_.st_mode &amp; S_IROTH)) &#123;        code_ &#x3D; 403;    &#125;    else if(code_ &#x3D;&#x3D; -1) &#123;         code_ &#x3D; 200;     &#125;    ErrorHtml_();    AddStateLine_(buff);    AddHeader_(buff);    AddContent_(buff);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>stat</code>用法如下 &gt;int stat(const char <em>path, struct stat </em>buf); &gt;stat() function is used to list properties of a file identified by path. It reads all file properties and dumps to buf structure. The function is defined in sys/stat.h header file. &gt;return 0 when success, -1 when unable to get file properties.</p><p>这里先判断是否能获得文件属性， - 不能获得文件属性 or 文件属性为目录 -&gt; <code>code_ = 404</code> - 其他组读权限 -&gt; <code>code_ = 403</code> - 没有异常情况 -&gt; <code>code_ = 200</code></p><p>之后根据<code>code_</code>到<code>errorHtml</code>，在这一步中如果根据错误码把<code>mmFileStat_</code>设置为对应的界面，如果<code>code</code>正常的话，其实这步会被跳过</p><p>调用<code>AddStateLine_</code>添加状态行</p><p>调用<code>AddHeader_</code>加入消息头</p><p>调用<code>AddContent_</code>添加消息内容</p><h2 id="buffer"><code>Buffer</code></h2><p><code>buffer</code>主要管理的是字符串的在并发场景下的存储和读取，从<code>buffer</code>的成员变量来看，<code>buffer</code>的组成是非常简单的 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::vector&lt;char&gt; buffer_;std::atomic&lt;std::size_t&gt; readPos_;std::atomic&lt;std::size_t&gt; writePos_;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre> - 一个可扩容的<code>vector</code> - <code>atomic</code>类型的<code>readPos_</code>和<code>writePos_</code>组成，<code>readPos_</code>表示读操作应该开始的位置，<code>writePos_</code>表示写操作应该开始的位置，<code>readPos_</code>和<code>writePos_</code>之间的区域则是写入了但还没有读的区域。</p><p>主要方法包括： - <code>retrieve(size_t len)</code>: 将<code>readPos_</code>向后移动<code>len</code> - <code>retrieveAll()</code>: <code>readPos_</code>和<code>writePos</code>都置为0 - <code>RetrieveAllToStr()</code>: 将<code>readPos_</code>和<code>writePos</code>读入到<code>string</code>中 - <code>MakeSpace(int len)</code>: 判断能写入的区域是否能容纳下写入的长度，不能的话就<code>resize</code>一下<code>buffer</code>，否则把待写的内容移动到<code>buffer</code>的最前端 - <code>Append(const char *str, size_t len)</code>: 先确保空间可用，不够就扩容，之后用<code>copy</code>函数将数据写入到<code>buffer</code>中，更新<code>writePos_</code> - <code>ReadFd(int fd, int *saveErrno)</code>: 使用<code>readv</code>函数从<code>fd</code>中读取内容到<code>buffer</code>中 - <code>WriteFd(int fd, int *saveErrno)</code>: 使用<code>write</code>函数将<code>buffer</code>内容写到<code>fd</code>中</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webserver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebserver源码阅读（一）</title>
      <link href="/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="主程序的步骤">主程序的步骤</h1><p>在本部分，主要去解析WebServer的四个主要组成部分 - Webserver类：供<code>main</code>函数使用的<code>webserver</code>主类，通过该类可以进行网络通信的各种连接 - Epoll类：通过<code>epoll</code>函数进行系统调用 - Thread类：负责线程池的管理 - Sql资源管理部分 从<code>main.cpp</code>中，我们可以看到，主程序做了两件事 - 创建一个<code>webServer</code> - 调用了<code>server.start()</code> 启动创建的<code>server</code> ## 1 WebServer类 下面进入到<code>WebServer</code>类的代码中一探究竟 ### 1.1 初始化 在列表初始化中，初始化了<code>port</code>,<code>Timer</code>,<code>ThreadPool</code>,<code>Epoller</code> 在构造函数中主要包含了以下步骤 1. 初始化<code>HttpConn</code>的静态变量，包括 - <code>userCount</code>: 默认为0 - <code>srcDir</code>: <code>getcwd + '/resources/'</code> 2. 初始化<code>SqlConnPool</code> 3. 初始化<code>Webserver</code>的<code>eventMode_</code> 4. <code>InitSocket_</code>: - 主要包含初始化socket的各种配置，创建<code>listenFd</code> 5. 初始化<code>log</code></p><p><code>InitSocket_</code>具体包含：</p><blockquote><ul><li>创建socket</li><li>设置数据没发送完毕的时候容许逗留（<a href="https://www.cnblogs.com/eeexu123/p/5275783.html">setsockopt用法介绍</a>） <code>setsockopt(listenFd_, SOL_SOCKET, SO_LINGER, &amp;optLinger, sizeof(optLinger));</code></li><li>设置端口复用 <code>setsockopt(listenFd_, SOL_SOCKET, SO_REUSEADDR, (const void*)&amp;optval, sizeof(int));</code></li><li>bind + listen</li><li>添加fd到监听红黑树上<ul><li>实际通过<code>Epoller</code>类进行操作，核心代码为<code>epoll_ctl(epollFd_, EPOLL_CTL_ADD, fd, &amp;ev)</code></li><li>修改<code>listenFd_</code>为非阻塞: <code>SetFdNonBlock(listenFd_)</code></li></ul></li></ul><h3 id="webserver的启动">1.2 WebServer的启动</h3><p>涉及到的是<code>WebServer Start</code>部分的代码，<code>timeMS</code>表示事件等待超时的时间 1. 判断<code>isClose_</code>是否为<code>true</code>，不为<code>true</code>时一直停留在循环内部（步骤2-步骤4） 2. 通过<code>timer</code>更新<code>timeMS</code> 3. 调用<code>int eventCnt = epoller_-&gt;Wait(timeMS);</code>获取满足监听事件的总数 4. 遍历获取的事件对事件进行处理 - 如果是<code>listenfd_</code>，调用<code>DealListen_()</code> - 如果<code>EPOLLRDHUP | EPOLLHUP | EPOLLERROR</code>调用<code>CloseConn_()</code> - 如果是<code>EPOLLIN</code>，调用<code>DealRead_()</code> - 如果是<code>EPOLLOUT</code>，调用<code>DealWrite_()</code> 5. 跳转至步骤1</p></blockquote><ul><li><code>DealListen_()</code>的处理</li></ul><blockquote><ul><li>调用<code>accept</code><ul><li>出错处理</li></ul></li><li>添加<code>client</code><ul><li>在<code>AddClient_</code>中执行</li><li>包括添加到<code>timer</code>，调用<code>epoller_-&gt;AddFd</code>添加到监听红黑树上，设置<code>nonblock</code>等一系列步骤</li></ul></li></ul></blockquote><ul><li><code>CloseConn_()</code>的处理</li></ul><blockquote><ul><li><code>epoller_-&gt;DelFd()</code></li><li><code>client</code>关闭连接</li></ul></blockquote><ul><li><code>DealRead_()</code>/<code>DealWrite_()</code>的处理</li></ul><blockquote><ul><li>延长时间</li><li>加入<code>threadPool</code></li></ul></blockquote><h2 id="epoller类">2 Epoller类</h2><p><code>Epoller</code>非常简单，主要是对<code>epoll</code>操作的封装，内部用<code>vector&lt;struct epoll_event&gt; events</code>存储监听树上的事件 主要方法如下 - <code>AddFd(int fd, uint32_t event)</code> - <code>ModFd(int fd, uint32_t event)</code> - <code>DelFd(int fd)</code> - <code>Wait(int timeoutMs)</code> - <code>GetEventFd(size_t i)</code> - <code>GetEvents(size_t i)</code> 这里可以直接参考<code>epoll</code>的用法</p><h2 id="thread类">3 Thread类</h2><p>核心代码在<code>pool/threadPool</code>中，在<code>ThreadPool</code>成员变量为<code>Pool</code> <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Pool &#123;    std::mutex mtx;    std::condition_variable cond;    bool isClosed;    std::queue&lt;std::function&lt;void()&gt;&gt; tasks; &#125;; std::shared_ptr&lt;Pool&gt; pool_;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 对其进行分析，里面主要含有锁<code>mutex</code>，条件变量<code>cond</code>，是否关闭<code>isClosed</code>，函数组成的队列<code>queue&lt;std::function&lt;void()&gt;&gt; tasks</code> <code>pool</code>是多个线程之间的共享资源，因为对<code>pool</code>的所有操作都需要先获取锁 ### 3.1 线程池 首先来到构造函数，它做的事是 - 初始化<code>pool_</code>: 这里采用<code>make_shared</code>进行初始化（<a href="https://www.jianshu.com/p/03eea8262c11">c11 make_shared</a>），构造函数建议使用<code>make_shared</code>而不是<code>new</code>分配对象 - 创建<code>threadCount</code>个线程：用<code>detach</code>方法作为后台线程，线程的使用可以参考<a href="https://thispointer.com/c11-multithreading-part-2-joining-and-detaching-threads/">joining-and-detaching-threads</a></p><p>创建的后台线程做的事如下： - 使用<code>std::unique_lock</code>创建一个锁（<a href="https://blog.csdn.net/shoufei403/article/details/107510476">使用方法</a>），该构造方法会直接对<code>mutex</code>对象加锁 - while循环中 - 当<code>tasks</code>不为空时，可以看到已经获取了<code>lock</code>，取出第一个<code>task</code>，释放<code>lock</code>,执行<code>task</code>，最后获取锁进到下一次循环中 - 当<code>tasks</code>为空时，如果有停止标志，退出循环，否则等待 - 当 <code>std::condition_variable</code> 对象的某个 wait 函数被调用的时候，它使用 <code>std::unique_lock</code>(通过 <code>std::mutex</code>) 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的 <code>std::condition_variable</code> 对象上调用了 <code>notification</code> 函数来唤醒当前线程 - 观察到在<code>addTask</code>方法中， <code>pool_-&gt;cond.notify_one()</code>会将其唤醒 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">explicit ThreadPool(size_t threadCount &#x3D; 8): pool_(std::make_shared&lt;Pool&gt;()) &#123;        assert(threadCount &gt; 0);        for(size_t i &#x3D; 0; i &lt; threadCount; i++) &#123;            std::thread([pool &#x3D; pool_] &#123;                std::unique_lock&lt;std::mutex&gt; locker(pool-&gt;mtx);                while(true) &#123;                    if(!pool-&gt;tasks.empty()) &#123;                        auto task &#x3D; std::move(pool-&gt;tasks.front());                        pool-&gt;tasks.pop();                        locker.unlock();                        task();                        locker.lock();                    &#125;                     else if(pool-&gt;isClosed) break;                    else pool-&gt;cond.wait(locker);                &#125;            &#125;).detach();        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ### 3.2 回调函数的放入 <code>std::function&lt;void()&gt;</code>是可调用对象包装器，可用于<code>callback</code>，参考<a href="https://stackoverflow.com/questions/11352936/why-do-we-use-stdfunction-in-c-rather-than-the-original-c-function-pointer">why use std::function</a>, <a href="https://stackoverflow.com/questions/55124517/stdfunction-and-stdbind-return-value">std::function and std::bind</a>, <a href="https://blog.csdn.net/Jxianxu/article/details/107382049">std::bind</a></p><p>整个放入到tasks到流程如下 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">threadpool_-&gt;AddTask(std::bind(&amp;WebServer::OnWrite_, this, client))void AddTask(F&amp;&amp; task) &#123;    &#123;        std::lock_guard&lt;std::mutex&gt; locker(pool_-&gt;mtx);        pool_-&gt;tasks.emplace(std::forward&lt;F&gt;(task));    &#125;    pool_-&gt;cond.notify_one();&#125;std::queue&lt;std::function&lt;void()&gt;&gt; tasks;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <code>std::bind</code>将<code>client</code>参数绑定到<code>WebServer::OnWrite_</code>方法，这样返回的<code>functor</code>就变为<code>void()</code>，放入到<code>std::function&lt;void()&gt;</code>可调用对象包装器中。</p><h3 id="析构函数">3.3 析构函数</h3><p>在析构函数中，需要唤醒阻塞的后台进程，使其结束。 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">~ThreadPool() &#123;    if(static_cast&lt;bool&gt;(pool_)) &#123;        &#123;            std::lock_guard&lt;std::mutex&gt; locker(pool_-&gt;mtx);            pool_-&gt;isClosed &#x3D; true;        &#125;        pool_-&gt;cond.notify_all();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ## 4 Sql资源管理 主要包含以下文件：<code>sqlConnRAII.h</code>, <code>sqlconnpool.h</code>, <code>sqlconnpool.c</code> ### 4.1 RAII机制 RAII（Resource Acquisition Is Initialization）为资源获取即初始化，<code>sqlConnRAII.h</code>专门负责了sql资源的连接，关键代码为在构造函数中调用<code>*sql = connpool-&gt;GetConn();</code>，在析构函数中调用<code>connpool_-&gt;FreeConn(sql_);</code> 内部成员有两个： - <code>MYSQL *sql_;</code> - <code>SqlConnPool* connpool_;</code> ### 4.2 SqlConnPool <code>sqlconnpool.h</code>中，静态方法为<code>instance</code>: 它用static声明了一个<code>SqlConnPool</code>对象并返回了一个地址 成员方法包括 - <code>MYSQL *GetConn()</code> - <code>void FreeConn(MYSQL conn)</code> - <code>int GetFreeConnCount()</code> - <code>void Init(args)</code> - <code>void ClosePool()</code> 成员变量包括 - <code>std::queue&lt;MYSQL *&gt; connQue_</code>; - <code>std::mutex mtx_</code>; - <code>sem_t semId_</code>; - <code>int MAX_CONN_</code>; #### 4.2.1 Init和ClosePool 首先来到<code>init</code>方法，它调用<code>connSize</code>次 - <code>mysql_init</code> - <code>mysql_real_connect</code> - 并<code>MYSQL</code>对象添加到<code>connQue_</code>中 之后初始化<code>MAC_CONN_</code>和初始化信号量<code>semId_</code>为<code>MAX_CONN_</code> 在<code>ClosePool</code>中，主要做的事情是清空<code>connQue_</code>,调用<code>mysql_library_end</code>结束<code>mysql</code> #### 4.2.2 GetConn和FreeConn 这里采用sem和<a href="https://blog.csdn.net/fengbingchun/article/details/78649260">lock_guard</a>对多线程并发访问进行控制，<code>sem_wait</code>和<code>sem_post</code>对连接数进行原子操作，<code>lock_guard</code>在构造时会自动获取锁，析构时会释放锁，用来取出<code>sql</code>对象 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MYSQL* SqlConnPool::GetConn() &#123;    MYSQL *sql &#x3D; nullptr;    if(connQue_.empty())&#123;        LOG_WARN(&quot;SqlConnPool busy!&quot;);        return nullptr;    &#125;    sem_wait(&amp;semId_);    &#123;        lock_guard&lt;mutex&gt; locker(mtx_);        sql &#x3D; connQue_.front();        connQue_.pop();    &#125;    return sql;&#125;void SqlConnPool::FreeConn(MYSQL* sql) &#123;    assert(sql);    lock_guard&lt;mutex&gt; locker(mtx_);    connQue_.push(sql);    sem_post(&amp;semId_);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="参考资料">参考资料</h2><ol type="1"><li>c11语法: <a href="https://www.codeproject.com/Articles/312029/Cplusplus-A-Glance-Part-of-n">Cplusplus-A-Glance-Part-of-n</a></li><li>c++多线程编程：<a href="https://www.cnblogs.com/haippy/p/3235560.html">C++11 并发指南</a></li><li>writev和readv：<a href="https://blog.csdn.net/weixin_36750623/article/details/84579243">高级I/O之readv和writev函数</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webserver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile</title>
      <link href="/2022/12/03/makefile/"/>
      <url>/2022/12/03/makefile/</url>
      
        <content type="html"><![CDATA[<h2 id="makefile工作原理">MakeFile工作原理</h2><h3 id="一个规则">一个规则</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">目标: 依赖条件生成方法<span class="token number">1</span>. 目标生成的时间必须晚于依赖条件的时间，否则，更新目录<span class="token number">2</span>. 依赖条件如果不存在，寻找新的规则去产生依赖hello:hello.cgcc hello.c <span class="token parameter variable">-o</span> hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会先检查依赖条件是否满足，如果满足则会执行，下面给出一个编译的例子 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ALL:a.out 指定makefile的终极目标a.out:hello.o add.o sub.o div.ogcc hello.o add.o sub.o div.o <span class="token parameter variable">-o</span> a.outhello.o:hello.cgcc <span class="token parameter variable">-c</span> hello.c <span class="token parameter variable">-o</span> hello.oadd.o:add.cgcc <span class="token parameter variable">-c</span> add.c <span class="token parameter variable">-o</span> add.osub.o:sub.cgcc <span class="token parameter variable">-c</span> sub.c <span class="token parameter variable">-o</span> sub.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任一个被更新，则目标必须更新 ### 两个函数 <code>$(wildcard *.c)</code>将后面格式<code>.c</code>的文件都提取出来，将文件名组成列表 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">src <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>wildcard *.c<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> <code>$(patsubst %.c, %.o, $(src))</code>：将参数3中，包含参数1的部分，替换为参数2 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">src <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>wildcard *.c<span class="token variable">)</span></span> obj <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>patsubst %.c, %.o, <span class="token punctuation">$(</span>src<span class="token punctuation">)</span><span class="token variable">)</span></span>myargs <span class="token operator">=</span> <span class="token parameter variable">-Wall</span> <span class="token parameter variable">-g</span>a.out:<span class="token variable"><span class="token variable">$(</span>obj<span class="token variable">)</span></span>gcc <span class="token variable"><span class="token variable">$(</span>obj<span class="token variable">)</span></span> <span class="token parameter variable">-o</span> a.out <span class="token variable"><span class="token variable">$(</span>myargs<span class="token variable">)</span></span>clean:<span class="token parameter variable">-rm</span> <span class="token parameter variable">-rf</span> <span class="token variable"><span class="token variable">$(</span>obj<span class="token variable">)</span></span> a.out <span class="token comment">#前面的-表示出错仍旧执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <code>clean</code>的模拟执行：<code>make clean -n</code>，不会实际执行</p><h3 id="三个自动变量">三个自动变量</h3><ul><li><code>$@</code>: 在规则的命令中，表示规则中的目标</li><li><code>$^</code>: 在规则的命令中，表示第所有依赖条件</li><li><code>$&lt;</code>: 在规则的命令中，表示第一个依赖条件，如果将该变量应用在模式规则中，可将依赖条件列表依次去除，套用模式规则</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">src <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>wildcard *.c<span class="token variable">)</span></span> obj <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>patsubst %.c, %.o, <span class="token punctuation">$(</span>src<span class="token punctuation">)</span><span class="token variable">)</span></span>a.out:<span class="token variable"><span class="token variable">$(</span>obj<span class="token variable">)</span></span>gcc $^ <span class="token parameter variable">-o</span> <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模式规则">模式规则</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">%o:%.cgcc $<span class="token operator">&lt;</span> <span class="token parameter variable">-o</span> <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>静态模式规则： <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>obj<span class="token variable">)</span></span>:%.o:%.cgcc <span class="token parameter variable">-c</span> $<span class="token operator">&lt;</span> <span class="token parameter variable">-o</span> <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre> 伪目标 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.PHONY: clean ALL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc使用</title>
      <link href="/2022/12/02/gcc%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/12/02/gcc%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="gcc编译">gcc编译</h2><h3 id="编译的四个步骤">编译的四个步骤</h3><ul><li>预处理(<code>gcc -E</code>)：展开宏、头文件，替换条件编译、删除注释、空行、空白(<code>hello.i</code>)</li><li>编译(<code>gcc -S</code>)：检查语法规范，得到汇编码(<code>hello.s</code>)</li><li>汇编(<code>gcc -c</code>)：将汇编指令翻译成机器码(<code>hello.o</code>)</li><li>链接：<strong>数据段合并，数据地址回填</strong>（<code>a.out</code>）</li></ul><p>消耗时间和系统资源最多的是<strong>编译阶段</strong></p><h3 id="常用参数">常用参数</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-I: 指定头文件所在目录位置-c：只做预处理 编译 汇编操作-g：编译时添加调试文件-On: <span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token number">0</span>~3, 优化程度-Wall: 显示所有的警告信息-D: 向程序中注册宏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态库和静态库">动态库和静态库</h3><p>使用场景 - 动态库：对时间要求较低，对空间要求较高 - 静态库：对空间要求较低，对时间要求较高</p><h4 id="制作静态库">制作静态库</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">先用gcc -c生成.o文件，再用ar生成库名ar rcs mylib.a add.o sub.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="制作动态库">制作动态库</h4><p>需要生成与位置无关的代码，在绑定动态库时会延迟绑定，通过汇编中@plt中进行判断 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc add.c <span class="token parameter variable">-o</span> add.o -fPIC<span class="token punctuation">(</span>生成位置无关代码<span class="token punctuation">)</span>gcc <span class="token parameter variable">-shared</span> lib库名.so add.o sub.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre> 编译可执行文件时，用<code>-l</code>指定库名，<code>-L</code>指定路径 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc test.c <span class="token parameter variable">-o</span> a.out <span class="token parameter variable">-lmymath</span> -L./lib -I./include<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> 链接器：工作在链接阶段，工作时需要<code>-l</code>和<code>-L</code></p><p>动态链接器：工作在运行阶段</p><p>由于动态库时运行时加载的，程序需要找到动态库的位置，需要设置环境变量，<code>export LD_LIBRARY_PATH=动态库路径</code></p><p>查看程序执行时要加载哪些动态库以及动态库路径 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ldd a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用指令</title>
      <link href="/2022/12/01/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/12/01/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="进程监控">进程监控</h2><h3 id="ps">ps</h3><p>显示进程信息 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> 进程号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> ### kill 强制关闭进程 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> <span class="token parameter variable">-9</span> 进程号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><h2 id="主机状态监控">主机状态监控</h2><h3 id="top">top</h3><p>查看系统整体资源 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span> <span class="token parameter variable">-p</span> 只显示进程信息<span class="token parameter variable">-d</span> 设置刷新时间<span class="token parameter variable">-n</span> 指定刷新次数<span class="token parameter variable">-u</span> 查找特定用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre> 以交互式进行，可以通过按键有各种功能</p><h3 id="netstat">netstat</h3><p>查看端口占用 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> <span class="token parameter variable">-an</span> <span class="token operator">|</span> <span class="token function">grep</span> 端口号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> 公认端口：1～1023，系统内置或常用知名软件绑定使用 注册端口：1024～49151:松散绑定（用户自定义） 动态端口：49152～65532:临时使用（多用于出口）</p><h3 id="df">df</h3><p>查看磁盘使用情况 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">df</span> <span class="token parameter variable">-h</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><h3 id="iostat">iostat</h3><p>查看CPU、磁盘相关情况 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iostat <span class="token parameter variable">-x</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> 主要去关注三个指标</p><p>rKB/S: 每秒发送到设备的读取请求数</p><p>wKB/S: 每秒发送到设备的写入请求数</p><p>%util：磁盘利用率</p><h3 id="sar">sar</h3><p>网络状态监控 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sar <span class="token parameter variable">-n</span> DEV<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> ## 环境变量 ### 查看环境变量 采用<code>env</code>查看，是<code>KEY-VALUE</code>的形式，可以通过<code>$</code>获得环境变量的值 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">env</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token environment constant">PATH</span><span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span>得到的就是执行程序的搜索路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre> ### 设置环境变量</p><h4 id="临时生效">临时生效</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">VAR</span><span class="token operator">=</span>xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="永久生效">永久生效</h4><ul><li>对当前用户生效 通过用户<code>home</code>目录下的<code>.bashrc</code>中<code>export</code></li><li>对全局有效 通过<code>vim /etc/profile</code></li></ul><h2 id="压缩和解压">压缩和解压</h2><p>常用2种压缩格式 - <code>.tar</code>：简单封装 - <code>.gz</code>：极大减小压缩后的体积</p><p>针对这两种格式，使用<code>tar</code>命令都可以进行压缩和解压缩的操作 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">压缩文件<span class="token punctuation">(</span>f一定要最后<span class="token punctuation">)</span><span class="token function">tar</span> <span class="token parameter variable">-cvf</span> test.tar <span class="token number">1</span>.txt <span class="token number">2</span>.txt <span class="token number">3</span>.txt <span class="token punctuation">(</span>会形成.tar<span class="token punctuation">)</span><span class="token function">tar</span> <span class="token parameter variable">-zcvf</span> test.tar <span class="token number">1</span>.txt <span class="token number">2</span>.txt <span class="token number">3</span>.txt<span class="token punctuation">(</span>会形成.gz<span class="token punctuation">)</span>解压文件<span class="token function">tar</span> <span class="token parameter variable">-xvf</span> test.tar <span class="token punctuation">(</span>到当前目录<span class="token punctuation">)</span><span class="token function">tar</span> <span class="token parameter variable">-xvf</span> test.tar <span class="token parameter variable">-C</span> /home <span class="token punctuation">(</span>-C 指定目的地<span class="token punctuation">)</span><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> test.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <code>zip</code>的使用 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">压缩文件<span class="token function">zip</span> test.zip a.txt b.txt<span class="token function">zip</span> <span class="token parameter variable">-r</span> test.zip <span class="token builtin class-name">test</span> a.txt b.txt<span class="token punctuation">(</span>带有文件夹时<span class="token punctuation">)</span>解压文件<span class="token function">unzip</span> test.zip <span class="token parameter variable">-d</span> 位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
