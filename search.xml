<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MIT6.824学习资料整理</title>
      <link href="/2022/12/17/MIT6-824%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
      <url>/2022/12/17/MIT6-824%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="课程部分"><a href="#课程部分" class="headerlink" title="课程部分"></a>课程部分</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>主要是从以下几个部分来介绍：</p><ul><li>GFS</li><li>VMWARE FT</li><li>Raft</li><li>Zookeeper</li><li>More Replication, CRAQ</li><li>Cloud Replicated DB, Aurora</li><li>Cache Consistency: Frangipani</li><li>Distributed Transaction</li></ul><p><a href="https://csdiy.wiki/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MIT6.824/">简单的课程中文介绍</a></p><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/">翻译版的gitbook</a></p><p><a href="https://www.zhihu.com/question/29597104">如何的才能更好地学习 MIT6.824 分布式系统课程？</a></p><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><h3 id="实验前必读"><a href="#实验前必读" class="headerlink" title="实验前必读"></a>实验前必读</h3><p><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">Students’ Guide to Raft</a></p><p><a href="http://nil.csail.mit.edu/6.824/2020/labs/raft-locking.txt">Raft Locking Advice</a></p><p><a href="http://nil.csail.mit.edu/6.824/2020/labs/raft-structure.txt">Raft Structure Advice</a></p><p>在分布式系统中如何利用<code>log</code>进行<code>debug</code>:<a href="https://blog.josejg.com/debugging-pretty/">Debugging by Pretty Printing</a></p><p><a href="http://nil.csail.mit.edu/6.824/2020/papers/raft-extended.pdf">Raft 一致性算法论文原文</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5Mjc3MjIyMA==&mid=2247544375&idx=1&sn=0cfa5651969bb136908f2bcaad7ecb2d&source=41#wechat_redirect">Raft 一致性算法论文中文译文</a></p><h3 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h3><p><a href="https://juejin.cn/post/7121928506476363789">lab 2中文版</a></p><h3 id="他人经验"><a href="#他人经验" class="headerlink" title="他人经验"></a>他人经验</h3><p><a href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021">lab1-lab4的思路分享</a></p><p><a href="https://zhuanlan.zhihu.com/p/464701798">mit6.824 Lab2 总结</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824——Go&amp;Thread&amp;Raft</title>
      <link href="/2022/12/17/MIT6-824%E2%80%94%E2%80%94Go-Thread-Raft/"/>
      <url>/2022/12/17/MIT6-824%E2%80%94%E2%80%94Go-Thread-Raft/</url>
      
        <content type="html"><![CDATA[<p>这一节课主要对<code>go</code>中会用到的模式进行讲解，感觉和<code>c++</code>多线程编程差不多吧，重点就是知道怎么使用</p><h2 id="并发原语"><a href="#并发原语" class="headerlink" title="并发原语"></a>并发原语</h2><p>首先是介绍了在<code>go</code>编程中使用的一些模式，同时需要注意的点</p><h3 id="go-loop"><a href="#go-loop" class="headerlink" title="go loop"></a>go loop</h3><p>经常利用 WaitGroup 来在父 goroutine 中阻塞地等待一组子 goroutine 的完结</p><p>在<code>go func</code>中，会使用外部函数内的变量，此时变量值和外部保持一致，因为最好是采用第二种方法传递进去，否则可能发生错误，因为在运行<code>go func</code>时，外部的<code>i</code>可能已经变了。</p><p><code>WaitGroup</code>的原理为，每次调用<code>wg.Add</code>会增加内部的计数器，<code>wg.Done</code>会减少</p><ol><li><p>当调用 WaitGroup.Add(n) 时，counter 将会自增: counter +&#x3D; n</p></li><li><p>当调用 WaitGroup.Wait() 时，会将 waiter++。同时调用 runtime_Semacquire(semap), 增加信号量，并挂起当前 goroutine。</p></li><li><p>当调用 WaitGroup.Done() 时，将会 counter–。如果自减后的 counter 等于 0，说明 WaitGroup 的等待过程已经结束，则需要调用 runtime_Semrelease 释放信号量，唤醒正在 WaitGroup.Wait 的 goroutine</p></li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go"># closure<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"sync"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> a <span class="token builtin">string</span>    <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        a <span class="token operator">=</span> <span class="token string">"hello world"</span>        wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"># loop<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"sync"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup    <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">&#123;</span>      wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token function">sendRPC</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>          wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">sendRPC</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定期做某事"><a href="#定期做某事" class="headerlink" title="定期做某事"></a>定期做某事</h3><p>如何控制</p><ul><li>定期做：<code>for loop + sleep</code></li><li>结束控制：<code>done变量 + lock控制并发访问</code></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"># sleep<span class="token operator">-</span>cancel<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"sync"</span><span class="token keyword">import</span> <span class="token string">"time"</span><span class="token keyword">var</span> done <span class="token builtin">bool</span><span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"started"</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">periodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    done <span class="token operator">=</span> <span class="token boolean">true</span>    mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"cancelled"</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">periodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"tick"</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> done<span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>        <span class="token punctuation">&#125;</span>        mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说到锁，一个很常用的模式就是<code>defer</code>的使用，其实就等价于把该语句放在函数题的结尾，避免忘记</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  counter <span class="token operator">=</span> counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>等价于<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  counter <span class="token operator">=</span> counter <span class="token operator">+</span> <span class="token number">1</span>  mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>定义：<code>cond := sync.NewCond(&amp;mu)</code></p><p>和条件变量相关的操作是<code>wait/broadcast/signal</code></p><p><code>cond.Signal</code> 每次仅唤起一个调用 <code>cond.Wait</code> 进入等待的线程，而 <code>cond.Broadcast</code> 会唤起所有等待在相应锁上的线程。</p><p><strong>需要注意的是：在使用时都应该放到lock内，在<code>cond.Signal</code>和<code>cond.Broadcast</code>使用完后需要释放锁</strong></p><p>给出一个Candidate 向所有 Followers 要票场景的例子</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    count <span class="token operator">:=</span> <span class="token number">0</span>    finished <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex    cond <span class="token operator">:=</span> sync<span class="token punctuation">.</span><span class="token function">NewCond</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mu<span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">&#123;</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        vote <span class="token operator">:=</span> <span class="token function">requestVote</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> vote<span class="token punctuation">&#123;</span>            count <span class="token operator">++</span>            <span class="token punctuation">&#125;</span>            finished <span class="token operator">++</span>            cond<span class="token punctuation">.</span><span class="token function">BroadCast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> count <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> finished <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">&#123;</span>    cond<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> count <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"received 5+ votes!"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lost"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    mu<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过这些例子，观察到一个重要的点是<strong>加锁的粒度</strong>，感觉可以从事务的原子性去类比考虑，哪些操作不能被打断，否则可能会带来race</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>无buffer的channels没有内部存储，作为一种<strong>同步通讯机制</strong>，当有人需要发送，有人需要接受，才会happen，否则会阻塞</p><p>适用于</p><ul><li>生产者消费者模型(buffered channel)</li><li><code>WaitGroup</code></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">sendRPC</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>done <span class="token operator">&lt;-</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token operator">&lt;-</span>done<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">sendRPC</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/7064220978825560072">MIT 6.824 视频笔记五：Go Concurrency</a></p><p><a href="https://www.bilibili.com/video/BV1CU4y1P7PE?p=5&vd_source=b2dfa40e00786129d946ba9ac4634819">MIT 6.824 Lecture 5</a></p><p><a href="https://zhuanlan.zhihu.com/p/344973865">Golang WaitGroup 原理深度剖析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程之美阅读笔记（一）</title>
      <link href="/2022/12/17/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/17/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>一直看到各路博主安利这门书，在家里的书柜里把之前买了一直没看的这本书又翻了出来。读这本书的感受大概是——很有意思的算法题……于是将有意思的题记录下来</p><h2 id="第一章-游戏之乐"><a href="#第一章-游戏之乐" class="headerlink" title="第一章 游戏之乐"></a>第一章 游戏之乐</h2><h3 id="将帅问题"><a href="#将帅问题" class="headerlink" title="将帅问题"></a>将帅问题</h3><p>中国象棋中的将帅不能碰面，假设A为将，B为帅，则A,B分别只能在己方3*3的格子里面运动，且不能碰面，请书写一个程序，输出A，B所有的合法位置，要求代码中只能用一个字节存储变量。</p><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>分析：题目的关键是<strong>一个字节</strong>存储，自然的想到用<strong>bit</strong>去存储位置，加上枚举就能得到结果。思路很简单，但是答案让我非常impressive的一点是<strong>简洁的<code>define</code>用法</strong> <del>虽然貌似在effective c++中不推荐使用define</del></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#define HALF_BITS_LENGTH 4#define FULLMASK 255#define RMASK (FULLMASK &gt;&gt; HALF_BITS_LENGTH)#define LMASK (FULLMASK &lt;&lt; HALF_BITS_LENGTH)#define LSET(b, n) (b&#x3D;((b&amp;RMASK)|(n&lt;&lt;HALF_BITS_LENGTH)))#define RSET(b, n) (b&#x3D;((b&amp;LMASK)|n))#define RGET(b) (b&amp;RMASK)#define LGET(b) ((b&amp;LMASK)&gt;&gt;HALF_BITS_LENGTH)#define MAXPOS 9int main()&#123;unsigned char b;    for(LSET(b,1); LGET(b)&lt;&#x3D;MAXPOS; LSET(b, LGET(b)+1))    &#123;    for(RSET(b,1); RGET(b)&lt;&#x3D;MAXPOS; RSET(b, RGET(b)+1))&#123;        if(LGET(b)%3!&#x3D;RGET(b)%3) printf(&quot;A&#x3D;%d, B&#x3D;%d\n&quot;, LGET(b), RGET(b));        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>刚刚是我们的标准解法，之后给出了其他的解法，首先看和标准解法最相近的第一种</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct&#123;unsigned char a:4;    unsigned char b:4;&#125;i;for(i.a&#x3D;1; i.a&lt;&#x3D;9; i.a++)&#123;for(i.b&#x3D;0; i.b&lt;&#x3D;9; i.b++)&#123;    if(i.a%3!&#x3D;i.b%3) printf(...);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里用到了<strong>位域</strong>，有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态，用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p><h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>最后一种解法的思路在想既然我们一共有<code>9*9</code>种位置的组合情况，我们需要的<code>pos1</code>和<code>pos2</code>要没有依赖关系，也就是在<code>pos1=x</code>时，<code>pos2</code>可以对所有值进行遍历，这个时候想到了除数，余数，其中一个取除数另一个取余数，这样就能遍历所有值了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(i&#x3D;1; i&lt;&#x3D;81; ++i)&#123;if(i%9%3 !&#x3D; i&#x2F;9%3) printf(...);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="到底哪种更快"><a href="#到底哪种更快" class="headerlink" title="到底哪种更快"></a>到底哪种更快</h4><p>对解法1～3进行测试，结果如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">解法一：time is 0.000130解法二：time is 0.000091解法三：time is 0.000081<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由此可见，解法3是最快的，真的是毫无多余操作惹</p><h3 id="如何找出故障的机器"><a href="#如何找出故障的机器" class="headerlink" title="如何找出故障的机器"></a>如何找出故障的机器</h3><p>题目：假设一个机器只存储一个标号为ID的记录，假设每份数据保存2个备份，这样就有2个机器存储了相同的数据。其中ID是小于10亿的整数</p><p>问题1、在某个时间，如果得到一个数据文件ID的列表。是否能够快速的找到这个表中仅出现一次的ID?即快速找出出现故障的机器存储的数据ID。</p><p>问题2、如果有两台机器死机呢？（假设同一个数据的俩个备份不会同时丢失，即列表中缺少的是两个不等的ID）</p><p>扩展题、如果所有的机子都有三个备份，也就是说同一ID的机子有三台。而且同时又有三台机子死机，还能用上面的方法解决吗？</p><p>如果有N台备份，又同时有N台机器死机呢？</p><p><strong>分析</strong>：已知一个数组，数组中只有<code>n</code>个数据是出现一遍的，其他数据都是出现两遍，我们要把这个数据找出来</p><p>给我最具有启发性idea是：</p><ul><li>异或操作：寻找一个函数<code>f</code>能将映射到要找的值中</li><li>不变量：有什么是不变的，哪些变化会带来这个不变量的变化</li></ul><h4 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h4><p>如果只有一台不同的机器，直接<code>异或</code>操作，最后就是结果啦！</p><p>但是当不同的机器上升为两台时，异或操作的结果就是这两台机器的异或值，如果有不同的位，可以分类讨论，直接安装这一位把原来的机器分为两类。</p><p>但是当机器数上升时，这个方法就不能用了。。。</p><h4 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h4><p>求和是一个不变量，因为可以直接求和，坏掉机器的id和&#x3D;原来的总和-现在的总和</p><p>在坏掉多台时，显然一个方程解不出来，那可以再加方程进入，例如平方和、乘积等等。这个就有了多个方程求解多个未知数了</p><p>思考了一下下，发现需要注意的点就是，加入的方程需要满足<strong>对称性</strong>，和已有式子的不相关性。<br>（虽然觉得在多台情况比较复杂时，可能采用计数+达到数量不存储可以更简单）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824——GFS文件系统</title>
      <link href="/2022/12/15/MIT6-824%E2%80%94%E2%80%94GFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/15/MIT6-824%E2%80%94%E2%80%94GFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统——GFS文件系统"><a href="#分布式系统——GFS文件系统" class="headerlink" title="分布式系统——GFS文件系统"></a>分布式系统——GFS文件系统</h1><p>参考论文: <a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf">https://pdos.csail.mit.edu/6.824/papers/gfs.pdf</a></p><p><img src="http://rn0ze8mqu.hn-bkt.clouddn.com/pasted-0.png"></p><p><img src="http://rn0ze8mqu.hn-bkt.clouddn.com/pasted-1.png"></p><p><img src="http://rn0ze8mqu.hn-bkt.clouddn.com/pasted-2.png"></p><p><img src="http://rn0ze8mqu.hn-bkt.clouddn.com/pasted-3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824——Primary-Backup Replication</title>
      <link href="/2022/12/15/MIT6-824%E2%80%94%E2%80%94Primary-Backup-Replication/"/>
      <url>/2022/12/15/MIT6-824%E2%80%94%E2%80%94Primary-Backup-Replication/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1CU4y1P7PE?p=4&vd_source=b2dfa40e00786129d946ba9ac4634819">课程链接</a></p><p>主从备份可以工作的前提是：主从机器出错的概率是相互独立的</p><h2 id="主从备份"><a href="#主从备份" class="headerlink" title="主从备份"></a>主从备份</h2><h3 id="同步状态的级别"><a href="#同步状态的级别" class="headerlink" title="同步状态的级别"></a>同步状态的级别</h3><ul><li><p>应用层</p><p>  GFS采取的是应用层的同步</p></li><li><p>机器层</p><p>  运行的服务器无需改动而获取容错能力，但需要更细粒度的同步，例如中断DMA</p></li></ul><h3 id="两种备份的方式"><a href="#两种备份的方式" class="headerlink" title="两种备份的方式"></a>两种备份的方式</h3><ul><li><p>State transfer(状态转移)</p><p>  持续增量同步Primary的状态到Backup，包括CPU、内存等，同步时需要占用较大带宽</p></li><li><p>Replicated State Machine（冗余状态机）</p><p>  同步的是外部事件&#x2F;操作&#x2F;输入，但是一些事件，例如随机数的生成，是不具有确定性的</p></li></ul><h3 id="backup过程"><a href="#backup过程" class="headerlink" title="backup过程"></a>backup过程</h3><p>virtual machine monitor可以感知到client发送的中断等信号，将这些信号转发到backup virtual machine monitor上。只有primary能生成数据回复，backup会drop掉恢复的包</p><p>primary和back会通过logging channel进行通信，如果发现找不到primary，就成为primary, 具体切换过程如下：</p><ul><li>Backup声称具有primary的mac地址，让ARP缓存表过期，这样IP的流量就会到Backup</li><li>切换后Backup成为新的primary</li></ul><p>Non-deterministic events</p><ul><li>Inputs-&gt;packet-&gt;data+interrupt:在哪条指令之间发生中断必须相同</li><li>weird instructions：随机数生成器</li><li>multi-core</li></ul><h3 id="logging-channel"><a href="#logging-channel" class="headerlink" title="logging channel"></a>logging channel</h3><p>为了进行容错（FT），我们使用日志条目（log entry ）来记录 Primary 上发生的事件；但我们并没有将这些日志写到硬盘中，而是将其通过日志通道（logging channel）传送到 Backup 上进行实时确定性的重建（deterministic replay），其包含</p><ul><li>instruction number: to handle interruption</li><li>type: to record weird instructions</li><li>data</li></ul><h3 id="OutPut-rule"><a href="#OutPut-rule" class="headerlink" title="OutPut rule"></a>OutPut rule</h3><p>用来保证指令primary如果发生宕机，发送给Backup的指令丢失带来的不一致性。<br>核心就是：等待收到 Backup 该条指令的 ACK 时，才会将该指令结果发送给用户。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebserver源码阅读（三）</title>
      <link href="/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在第三部分，主要对日志系统<code>log</code>和定时器<code>timer</code>进行分析</p><h2 id="1-日志log"><a href="#1-日志log" class="headerlink" title="1 日志log"></a>1 日志<code>log</code></h2><p><code>log</code>部分由三部分组成，<code>blockqueue.h</code>, <code>log.h</code>, <code>log.cpp</code>，<code>blockqueue</code>是封装的类似<code>deque</code>的能进行并发访问和操作的底层结构，<code>log.cpp</code>实现了日志的功能</p><h3 id="1-1-blockqueue的实现"><a href="#1-1-blockqueue的实现" class="headerlink" title="1.1 blockqueue的实现"></a>1.1 <code>blockqueue</code>的实现</h3><h4 id="1-1-1-成员变量和方法分析"><a href="#1-1-1-成员变量和方法分析" class="headerlink" title="1.1.1 成员变量和方法分析"></a>1.1.1 成员变量和方法分析</h4><p><code>blockqueue</code>和<code>deque</code>的功能是类似的，主要是在<code>deque</code>上加了一层并发访问的控制，其调用接口包括了<code>empty()</code>, <code>full()</code>, <code>Close()</code>, <code>size()</code>, <code>capacity()</code>, <code>front()</code>, <code>back()</code>, <code>push_back(const T &amp;item)</code>, <code>push_front(const T &amp;item)</code>, 稍有区别的为</p><ul><li><code>bool pop(T &amp;item)</code>: 如果<code>isClose_</code>为<code>true</code>返回<code>false</code>，否则返回<code>true</code>，首个元素会被放在<code>item</code>中</li><li><code>bool pop(T &amp;item, int timeout)</code>: 如果<code>isClose_</code>为<code>true</code>或者在<code>timeout</code>时间内没有返回，返回<code>false</code></li></ul><p>对成员变量进行分析，包括</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::deque&lt;T&gt; deq_; &#x2F;&#x2F; deque双端队列size_t capacity_; &#x2F;&#x2F; 容量std::mutex mtx_; &#x2F;&#x2F;锁mutexbool isClose_; &#x2F;&#x2F;是否关闭std::condition_variable condConsumer_; &#x2F;&#x2F; 生产者信号量std::condition_variable condProducer_; &#x2F;&#x2F; 消费者信号量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   从成员变量中，可以猜测出使用的是生产者消费者模型，生成者向<code>deq_</code>中添加元素，消费者从<code>deq_</code>中取出元素</p><h4 id="1-1-2-元素的访问"><a href="#1-1-2-元素的访问" class="headerlink" title="1.1.2 元素的访问"></a>1.1.2 元素的访问</h4><p>元素的访问不涉及到对<code>deq_</code>的操作，因为在访问之前只用获取<code>mtx_</code>的锁然后去访问元素就行，下面给出<code>back</code>和<code>empty</code>的例子</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class T&gt;T BlockQueue&lt;T&gt;::back()&#123;std::lock_guard&lt;std::mutex&gt; locker(mtx_):return deq_.back();&#125;template&lt;class T&gt;bool BlockQueue&lt;T&gt;::empty()&#123;std::lock_guard&lt;std::mutex&gt; locker(mtx_);return deq_.empty();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里<code>lock_guard</code>在初始化的时候，可以自动获取锁</p><h4 id="1-1-4-元素的操作"><a href="#1-1-4-元素的操作" class="headerlink" title="1.1.4 元素的操作"></a>1.1.4 元素的操作</h4><p>在涉及对元素的操作时，情况就稍稍复杂一点点，这时候不仅要考虑并发读，也要考虑并发写，还需要考虑<code>deq_</code>为空的情况。这里主要用两个操作进行举例，<code>push_back</code>和<code>pop</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class T&gt;void BlockQueue::push_back(const T &amp;item)&#123;std::lock_guard&lt;std::mutex&gt; locker(mtx_);&#123;while(deq_.size()&gt;&#x3D;Capacity())&#123;condProducer_.wait(locker);&#125;deq_.push_back(item);condConsumer_.notify_one();&#125;&#125;template&lt;class T&gt;bool BlockQueue::pop(T &amp;item)&#123;std::lock_guard&lt;std::mutex&gt; locker(mtx_);while(deq_.empty())&#123;condConsumer_.wait(locker);if(isClose_)&#123;return false;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-5-初始化和关闭"><a href="#1-1-5-初始化和关闭" class="headerlink" title="1.1.5 初始化和关闭"></a>1.1.5 初始化和关闭</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class T&gt;BlockDeque&lt;T&gt;::BlockDeque(size_t MaxCapacity) :capacity_(MaxCapacity) &#123;    assert(MaxCapacity &gt; 0);    isClose_ &#x3D; false;&#125;template&lt;class T&gt;void BlockDeque&lt;T&gt;::Close() &#123;    &#123;           std::lock_guard&lt;std::mutex&gt; locker(mtx_);        deq_.clear();        isClose_ &#x3D; true;    &#125;    condProducer_.notify_all();    condConsumer_.notify_all();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化的时候主要是去初始化了<code>capability_</code>，并设置<code>isClose_</code>为<code>false</code>，在关闭时把<code>isClose_</code>设置为<code>true</code>，并用信号量<code>condProducer_</code>和<code>condCustomer_</code>通知阻塞的线程。注意<code>isClose_</code>变量是为了告诉其他线程，它需要结束了，这样在<code>pop</code>的时候会返回<code>false</code></p><h2 id="1-2-log的实现"><a href="#1-2-log的实现" class="headerlink" title="1.2 log的实现"></a>1.2 <code>log</code>的实现</h2><p><code>log</code>采用的也是单例模式</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static Log* instance();Log* Log::instance()&#123;static Log log;return &amp;log;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>log</code>的成员变量包括</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const char* path_; &#x2F;&#x2F; 路径const char* suffix_; &#x2F;&#x2F; 后缀int MAX_LINES_; &#x2F;&#x2F; 最大行数int lineCount_; &#x2F;&#x2F; 目前的行数int toDay_; &#x2F;&#x2F; 是多少号 tm.tm_mdaybool isOpen_; &#x2F;&#x2F; 是否打开 Buffer buff_; &#x2F;&#x2F; 缓冲区int level_; &#x2F;&#x2F; 日志级别bool isAsync_; &#x2F;&#x2F; 是否异步FILE* fp_; &#x2F;&#x2F; 文件指针std::unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; deque_; &#x2F;&#x2F; blockQueue队列std::unique_ptr&lt;std::thread&gt; writeThread_; &#x2F;&#x2F; 写日志的线程std::mutex mtx_; &#x2F;&#x2F; 锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-1-init方法"><a href="#1-2-1-init方法" class="headerlink" title="1.2.1 init方法"></a>1.2.1 <code>init</code>方法</h3><p>在<code>init</code>方法中，会初始化日志级别<code>level</code>，路径<code>path</code>，后缀<code>suffix</code>，缓冲区的最大长度<code>maxQueueSize</code>，它做了以下事情</p><ul><li>初始化<code>deque_</code>和<code>writeThread_</code><ul><li>新的<code>thread</code>采用<code>new thread(FlushLogThread)</code>,<code>FlushLogThread</code>是一个静态方法，它获得<code>Log::instance</code>并调用其<code>AsyncWrite_</code>将<code>deque_</code>的内容写出。</li></ul></li><li>创建<code>log</code>文件，在此前检查<code>fp_</code>有没有被打开，如果被打开先把内容写回。该操作涉及到临界区资源，因此需要申请锁<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Log::init(int level &#x3D; 1, const char* path, const char* suffix, int maxQueueSize) &#123;    isOpen_ &#x3D; true;    level_ &#x3D; level;    if(maxQueueSize &gt; 0) &#123;        isAsync_ &#x3D; true;        if(!deque_) &#123;            unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; newDeque(new BlockDeque&lt;std::string&gt;);            deque_ &#x3D; move(newDeque);            std::unique_ptr&lt;std::thread&gt; NewThread(new thread(FlushLogThread));            writeThread_ &#x3D; move(NewThread);        &#125;    &#125; else &#123;        isAsync_ &#x3D; false;    &#125;    lineCount_ &#x3D; 0;    time_t timer &#x3D; time(nullptr);    struct tm *sysTime &#x3D; localtime(&amp;timer);    struct tm t &#x3D; *sysTime;    path_ &#x3D; path;    suffix_ &#x3D; suffix;    char fileName[LOG_NAME_LEN] &#x3D; &#123;0&#125;;    snprintf(fileName, LOG_NAME_LEN - 1, &quot;%s&#x2F;%04d_%02d_%02d%s&quot;,             path_, t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, suffix_);    toDay_ &#x3D; t.tm_mday;    &#123;        lock_guard&lt;mutex&gt; locker(mtx_);        buff_.RetrieveAll();        if(fp_) &#123;             flush();            fclose(fp_);         &#125;        fp_ &#x3D; fopen(fileName, &quot;a&quot;);        if(fp_ &#x3D;&#x3D; nullptr) &#123;            mkdir(path_, 0777);            fp_ &#x3D; fopen(fileName, &quot;a&quot;);        &#125;         assert(fp_ !&#x3D; nullptr);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="1-2-2-LOG-BASE方法"><a href="#1-2-2-LOG-BASE方法" class="headerlink" title="1.2.2 LOG_BASE方法"></a>1.2.2 <code>LOG_BASE</code>方法</h3><p>在实际使用中，我们采用的是<code>LOG_INFO</code>, <code>LOG_WARN</code>等方法，其定义如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LOG_DEBUG(format, ...) do &#123;LOG_BASE(0, format, ##__VA_ARGS__)&#125; while(0);#define LOG_INFO(format, ...) do &#123;LOG_BASE(1, format, ##__VA_ARGS__)&#125; while(0);#define LOG_WARN(format, ...) do &#123;LOG_BASE(2, format, ##__VA_ARGS__)&#125; while(0);#define LOG_ERROR(format, ...) do &#123;LOG_BASE(3, format, ##__VA_ARGS__)&#125; while(0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它们底层都利用的是<code>LOG_BASE</code>方法，只是设置了不同的日志级别<code>level</code>，那<code>LOG_BASE</code>又做了什么事呢？下面针对代码进行分析</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LOG_BASE(level, format, ...) \    do &#123;\        Log* log &#x3D; Log::Instance();\        if (log-&gt;IsOpen() &amp;&amp; log-&gt;GetLevel() &lt;&#x3D; level) &#123;\            log-&gt;write(level, format, ##__VA_ARGS__); \            log-&gt;flush();\        &#125;\    &#125; while(0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里涉及到一个使用<a href="https://www.jianshu.com/p/4ac2195ea9b6">do_while(0)</a>，该操作是为了在<code>define</code>宏中封装较为复杂的代码。</p><ul><li>首先调用<code>Log::instance()</code>获取<code>log</code></li><li>如果<code>log</code>打开并且日志等级小于<code>level</code>，表示需要写入日志，调用<code>log-&gt;write</code>和<code>log-&gt;flush</code></li></ul><h3 id="1-2-3-write方法"><a href="#1-2-3-write方法" class="headerlink" title="1.2.3 write方法"></a>1.2.3 <code>write</code>方法</h3><p><code>write</code>做的事情如下：</p><ul><li>判断打开的日志是否写满 or 日期是否和现在日期相等，如果写满了或者日期不相等，把已有内容用<code>flush</code>写回，创建一个新的<code>fp_</code>（在此期间因为涉及到对<code>buff_</code>和<code>fp_</code>的操作，需要<code>locker</code>）</li><li>向<code>buffer_</code>中写入日期，写入<code>log level title</code>，写入传入的参数</li><li>如果是异步操作，把<code>buffer</code>中的内容放到<code>deque_</code>中，否则直接<code>fputs</code>，调用<code>buff_.retrieveAll()</code>表示所有的内容都已写，改变其<code>readPos_</code></li><li><code>flush</code>操作，会调用<code>deque_-&gt;flush()</code>去<code>notify_one</code>一个线程，并且会用<code>fflush(fp_)</code>去将缓冲区的内容写回。</li></ul><h2 id="2-timer分析"><a href="#2-timer分析" class="headerlink" title="2 timer分析"></a>2 <code>timer</code>分析</h2><h3 id="2-1-timerNode分析"><a href="#2-1-timerNode分析" class="headerlink" title="2.1 timerNode分析"></a>2.1 <code>timerNode</code>分析</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef std::function&lt;void()&gt; TimeoutCallBack;typedef std::chrono::high_resolution_clock Clock;typedef std::chrono::milliseconds MS;typedef Clock::time_point TimeStamp;struct TimerNode &#123;    int id;    TimeStamp expires;    TimeoutCallBack cb;    bool operator&lt;(const TimerNode&amp; t) &#123;        return expires &lt; t.expires;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>TimerNode</code>有三个属性，<code>id</code>，<code>expire</code>到期时间，<code>timeoutCallBack</code>在时间到期后的回调函数，其重载了<code>operator &lt;</code>按照<code>expire</code>进行比较</p><h3 id="2-2-HeapTimer"><a href="#2-2-HeapTimer" class="headerlink" title="2.2 HeapTimer"></a>2.2 <code>HeapTimer</code></h3><p><code>heapTimer</code>自定义<br>其成员变量有两个</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::vector&lt;TimerNode&gt; heap_;std::unordered_map&lt;int, size_t&gt; ref_;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> <code>heap_</code>用来存储<code>TimerNode</code></p><h4 id="2-2-1-堆的构建"><a href="#2-2-1-堆的构建" class="headerlink" title="2.2.1 堆的构建"></a>2.2.1 堆的构建</h4><p> 参考<code>STL</code>中堆的构建方法，<br>首先看<code>siftup_</code>代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HeapTimer::siftup_(size_t i)&#123;assert(i&gt;&#x3D;0 &amp;&amp; i&lt;heap.size());size_t j &#x3D; (i-1)&#x2F;2; &#x2F;&#x2F;找到父节点while(j&gt;&#x3D;0)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webserver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebserver源码阅读（二）</title>
      <link href="/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要介绍<code>Http</code>和<code>Buffer</code>部分<br><code>Http</code>请求和响应部分，其主要包含三个类<code>httpConn</code>, <code>httpRequest</code>, <code>httpResponse</code><br><code>Buffer</code>解决的是并发情况下的读写问题</p><h2 id="1-http请求和响应报文"><a href="#1-http请求和响应报文" class="headerlink" title="1. http请求和响应报文"></a>1. http请求和响应报文</h2><p>首先让我们熟悉一下请求（Request）和响应（Response）报文，这两种报文在<code>WebServer</code>服务器中分别对应<code>httpRequest</code>和<code>httpResponse</code>类进行处理。</p><h3 id="1-1-http请求报文"><a href="#1-1-http请求报文" class="headerlink" title="1.1 http请求报文"></a>1.1 http请求报文</h3><p>HTTP请求报文由四部分组成：</p><ul><li>请求行</li><li>请求头部</li><li>空行</li><li>请求数据</li></ul><p>请求分为两种，GET和POST，让我们来看一个例子<br>GET</p><pre class="line-numbers language-http" data-language="http"><code class="language-http">（请求行部分）<span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=</span> <span class="token http-version property">HTTP/1.1</span></span>  （请求头部分）<span class="token header"><span class="token header-name keyword">Accept</span><span class="token punctuation">:</span> <span class="token header-value">image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, application/x-silverlight, application/x-shockwave-flash, */*  </span></span><span class="token header"><span class="token header-name keyword">Referer</span><span class="token punctuation">:</span> <span class="token header-value">&lt;a href="http://www.google.cn/">http://www.google.cn/&lt;/a>  </span></span><span class="token header"><span class="token header-name keyword">Accept-Language</span><span class="token punctuation">:</span> <span class="token header-value">zh-cn  </span></span><span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">gzip, deflate  </span></span><span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span> <span class="token header-value">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  </span></span><span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">&lt;a href="http://www.google.cn">www.google.cn&lt;/a>  </span></span><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">Keep-Alive  </span></span><span class="token header"><span class="token header-name keyword">Cookie</span><span class="token punctuation">:</span> <span class="token header-value">PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r</span></span>（空行）（请求数据）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>POST</p><pre class="line-numbers language-http" data-language="http"><code class="language-http">POST / HTTP1.1<span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span><span class="token header-value">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span></span><span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span><span class="token header-value">application/x-www-form-urlencoded</span></span><span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span><span class="token header-value">40</span></span><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">Keep-Alive</span></span>空行name=Professional%20Ajax&amp;publisher=Wiley<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-http响应报文"><a href="#1-2-http响应报文" class="headerlink" title="1.2 http响应报文"></a>1.2 http响应报文</h3><p>http响应报文由四部分组成</p><ul><li>状态行</li><li>消息报头</li><li>空行</li><li>响应正文<br>一个例子如下<pre class="line-numbers language-http" data-language="http"><code class="language-http">（状态行）<span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span>（消息报头）<span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Sat, 31 Dec 2005 23:59:59 GMT</span></span><span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html;charset=ISO-8859-1</span></span><span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">122</span></span>（空行）（响应正文）＜html＞＜head＞＜title＞Wrox Homepage＜/title＞＜/head＞＜body＞＜!-- body goes here --＞＜/body＞＜/html＞<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2-httpConn类"><a href="#2-httpConn类" class="headerlink" title="2 httpConn类"></a>2 <code>httpConn</code>类</h2><p><code>httpConn</code>类处理的是和<code>http</code>连接相关的问题，它用于处理和<code>client</code>的连接<br>其成员变量有</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static bool isET; &#x2F;&#x2F; 是否是边缘触发static const char* srcDir; &#x2F;&#x2F;根路径static std::atomic&lt;int&gt; userCount; &#x2F;&#x2F;总用户数int fd_; &#x2F;&#x2F;文件描述符struct  sockaddr_in addr_; &#x2F;&#x2F;连接时的socket地址bool isClose_; &#x2F;&#x2F;是否关闭int iovCnt_; &#x2F;&#x2F;供readv&#x2F;writev使用，表示缓冲区的个数struct iovec iov_[2]; &#x2F;&#x2F;供readv&#x2F;writev使用，表示缓冲区地址(iov_base)和长度(iov_len)的结构体Buffer readBuff_; &#x2F;&#x2F; 读缓冲区Buffer writeBuff_; &#x2F;&#x2F; 写缓冲区HttpRequest request_; &#x2F;&#x2F; httpRequest对象HttpResponse response_; &#x2F;&#x2F; httpResponse对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   从成员变量中就可以看出，<code>httpConn</code>就是<code>http</code>连接的一个表示，因为成员函数就显而易见了</p><ul><li><code>init/close</code>: 初始化<code>httpConn</code>和关闭文件</li><li><code>read/write</code>:读取数据到<code>readBuff</code>中&#x2F;将<code>writeBuff</code>中写出</li><li><code>process</code>: 解析<code>readBuff</code>，将相应的<code>response</code>写到<code>writeBuff</code></li><li><code>IsKeepAlive</code>: 是否还保持连接，通过<code>request_</code>的<code>isKeepAlive</code>进行判断</li><li><code>get</code>相关的方法: 获得地址&#x2F;端口号等等</li></ul><h3 id="2-1-init和close"><a href="#2-1-init和close" class="headerlink" title="2.1 init和close"></a>2.1 <code>init</code>和<code>close</code></h3><p><code>init</code>: 初始化成员变量和静态变量，例如<code>userCount++</code>,设置<code>fd</code>, <code>addr</code>，初始化<code>writeBuff</code>和<code>readBuff</code>等等<br><code>close</code>: 解除<code>response_</code>建立的文件映射，<code>userCount--</code>,关闭<code>fd</code>，设置<code>isClosed</code>，在析构函数中会调用<code>close</code></p><h3 id="2-2-read"><a href="#2-2-read" class="headerlink" title="2.2 read"></a>2.2 <code>read</code></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ssize_t HttpConn::read(int* saveErrno) &#123;    ssize_t len &#x3D; -1;    do &#123;        len &#x3D; readBuff_.ReadFd(fd_, saveErrno);        if (len &lt;&#x3D; 0) &#123;            break;        &#125;    &#125; while (isET);    return len;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-write"><a href="#2-3-write" class="headerlink" title="2.3 write"></a>2.3 <code>write</code></h3><p>当<code>fd</code>注册<code>EPOLLIN</code>事件时，当TCP读缓冲区有数据到达时就会触发<code>EPOLLIN</code>事件。当<code>fd</code>注册<code>EPOLLOUT</code>事件时，当TCP写缓冲区有剩余空间时就会触发<code>EPOLLOUT</code>事件，此时<code>DealWrite</code>就是处理<code>EPOLLOUT</code>事件。<br>这里有一个问题是，为什么要放到循环中?</p><blockquote><p>查看<code>writev</code>的用法有提到<br>When using non-blocking I&#x2F;O on objects, such as sockets, that are subject to flow control, write() and writev() may write fewer bytes than requested; the return value must be noted, and the remainder of the operation should be retried when possible</p></blockquote><p><code>writev</code>是分散写,也就是你的数据可以这里一块,那里一块,然后只要将这些数据的首地址,长度什么的写到一个<code>iovc</code>的结构体数组里,传递给<code>writev</code>,<code>writev</code>就帮你来写这些数据,在你看来,分散的数据就像是连成了一体。但是在非阻塞IO的情况下，如果writev返回一个大于0的值num,这个值又小于所有要传递的文件块的总长度,这意味着什么,意味着数据还没有写完。如果你还想写的话,你下一次调用writev的时候要重新整理iovc数组</p><pre class="line-numbers language-none"><code class="language-none">ssize_t HttpConn::write(int* saveErrno) &#123;    ssize_t len &#x3D; -1;    do &#123;        len &#x3D; writev(fd_, iov_, iovCnt_);        if(len &lt;&#x3D; 0) &#123;            *saveErrno &#x3D; errno;            break;        &#125;        if(iov_[0].iov_len + iov_[1].iov_len  &#x3D;&#x3D; 0) &#123; break; &#125; &#x2F;* 传输结束 *&#x2F;        else if(static_cast&lt;size_t&gt;(len) &gt; iov_[0].iov_len) &#123;            iov_[1].iov_base &#x3D; (uint8_t*) iov_[1].iov_base + (len - iov_[0].iov_len);            iov_[1].iov_len -&#x3D; (len - iov_[0].iov_len);            if(iov_[0].iov_len) &#123;                writeBuff_.RetrieveAll();                iov_[0].iov_len &#x3D; 0;            &#125;        &#125;        else &#123;            iov_[0].iov_base &#x3D; (uint8_t*)iov_[0].iov_base + len;             iov_[0].iov_len -&#x3D; len;             writeBuff_.Retrieve(len);        &#125;    &#125; while(isET || ToWriteBytes() &gt; 10240);    return len;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-process函数"><a href="#2-4-process函数" class="headerlink" title="2.4 process函数"></a>2.4 <code>process</code>函数</h3><ul><li>初始化<code>request_</code>: <code>request_.init()</code></li><li>解析<code>readBuff_</code>: <code>request.parse(readBuff_)</code>,同时用解析的内容初始化<code>response_</code></li><li>生成回应内容: <code>response_.makeResponse()</code></li><li>更新<code>iov</code>和<code>iov_cnt</code>: <code>iov[0]</code>存储的是响应头，<code>iov[1]</code>存储的是响应文件<code>response_.File()</code></li></ul><h2 id="3-httpRequest类"><a href="#3-httpRequest类" class="headerlink" title="3 httpRequest类"></a>3 <code>httpRequest</code>类</h2><p>我们仍旧从成员变量开始分析</p><pre class="line-numbers language-none"><code class="language-none">PARSE_STATE state_; &#x2F;&#x2F; 状态std::string method_, path_, version_, body_; &#x2F;&#x2F;方法，路径，版本，请求体std::unordered_map&lt;std::string, std::string&gt; header_; &#x2F;&#x2F;请求头std::unordered_map&lt;std::string, std::string&gt; post_; &#x2F;&#x2F;post的内容static const std::unordered_set&lt;std::string&gt; DEFAULT_HTML;static const std::unordered_map&lt;std::string, int&gt; DEFAULT_HTML_TAG;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以看出<code>httpRequest</code>是对<code>socket</code>解析到的<code>http</code>状态的解析和保存。最主要的是<code>parse</code>函数，剩下的就约等于字符串的处理，将处理的字符串保存在成员变量中。</p><h3 id="3-1-parse函数"><a href="#3-1-parse函数" class="headerlink" title="3.1 parse函数"></a>3.1 <code>parse</code>函数</h3><p> 其利用有限状态机模型，每次解析一行，从已知状态跳转到下一个状态，可以参考1.1中的<code>http</code>请求报文<br> <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> bool HttpRequest::parse(Buffer&amp; buff) &#123;    const char CRLF[] &#x3D; &quot;\r\n&quot;;    if(buff.ReadableBytes() &lt;&#x3D; 0) &#123;        return false;    &#125;    while(buff.ReadableBytes() &amp;&amp; state_ !&#x3D; FINISH) &#123;        const char* lineEnd &#x3D; search(buff.Peek(), buff.BeginWriteConst(), CRLF, CRLF + 2);        std::string line(buff.Peek(), lineEnd);        switch(state_)        &#123;        case REQUEST_LINE:            if(!ParseRequestLine_(line)) &#123;                return false;            &#125;            ParsePath_(); &#x2F;&#x2F; state在其中会被置为HEADERS            break;            case HEADERS:            ParseHeader_(line); &#x2F;&#x2F; state被置为BODY            if(buff.ReadableBytes() &lt;&#x3D; 2) &#123;                state_ &#x3D; FINISH;            &#125;            break;        case BODY:            ParseBody_(line);            break;        default:            break;        &#125;        if(lineEnd &#x3D;&#x3D; buff.BeginWrite()) &#123; break; &#125;        buff.RetrieveUntil(lineEnd + 2);    &#125;    LOG_DEBUG(&quot;[%s], [%s], [%s]&quot;, method_.c_str(), path_.c_str(), version_.c_str());    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="3-2-parseHeader"><a href="#3-2-parseHeader" class="headerlink" title="3.2 parseHeader"></a>3.2 <code>parseHeader</code></h3><p>直接采用<code>regex</code>字符串匹配，将陪陪的字符串保存在<code>header</code>中</p><pre class="line-numbers language-none"><code class="language-none">void HttpRequest::ParseHeader_(const string&amp; line) &#123;    regex patten(&quot;^([^:]*): ?(.*)$&quot;);    smatch subMatch;    if(regex_match(line, subMatch, patten)) &#123;        header_[subMatch[1]] &#x3D; subMatch[2];    &#125;    else &#123;        state_ &#x3D; BODY;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-httpResponse类"><a href="#4-httpResponse类" class="headerlink" title="4 httpResponse类"></a>4 <code>httpResponse</code>类</h2><p>成员变量如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int code_; &#x2F;&#x2F; status codebool isKeepAlive_;std::string path_;std::string srcDir_;char* mmFile_; &#x2F;&#x2F;struct stat mmFileStat_;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-1-init"><a href="#4-1-init" class="headerlink" title="4.1 init"></a>4.1 <code>init</code></h3><p>采用<code>response_.parse()</code>获得的<code>src</code>, <code>path</code>, <code>code</code>, <code>keepalive</code>进行初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HttpResponse::Init(const string&amp; srcDir, string&amp; path, bool isKeepAlive, int code)&#123;    assert(srcDir !&#x3D; &quot;&quot;);    if(mmFile_) &#123; UnmapFile(); &#125;    code_ &#x3D; code;    isKeepAlive_ &#x3D; isKeepAlive;    path_ &#x3D; path;    srcDir_ &#x3D; srcDir;    mmFile_ &#x3D; nullptr;     mmFileStat_ &#x3D; &#123; 0 &#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-makeResponse"><a href="#4-2-makeResponse" class="headerlink" title="4.2 makeResponse"></a>4.2 <code>makeResponse</code></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HttpResponse::MakeResponse(Buffer&amp; buff) &#123;    &#x2F;* 判断请求的资源文件 *&#x2F;    if(stat((srcDir_ + path_).data(), &amp;mmFileStat_) &lt; 0 || S_ISDIR(mmFileStat_.st_mode)) &#123;        code_ &#x3D; 404;    &#125;    else if(!(mmFileStat_.st_mode &amp; S_IROTH)) &#123;        code_ &#x3D; 403;    &#125;    else if(code_ &#x3D;&#x3D; -1) &#123;         code_ &#x3D; 200;     &#125;    ErrorHtml_();    AddStateLine_(buff);    AddHeader_(buff);    AddContent_(buff);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>stat</code>用法如下</p><blockquote><p>int stat(const char *path, struct stat *buf);<br>stat() function is used to list properties of a file identified by path. It reads all file properties and dumps to buf structure. The function is defined in sys&#x2F;stat.h header file.<br>return 0 when success, -1 when unable to get file properties.</p></blockquote><p>这里先判断是否能获得文件属性，</p><ul><li>不能获得文件属性 or 文件属性为目录 -&gt; <code>code_ = 404</code></li><li>其他组读权限 -&gt; <code>code_ = 403</code></li><li>没有异常情况 -&gt; <code>code_ = 200</code></li></ul><p>之后根据<code>code_</code>到<code>errorHtml</code>，在这一步中如果根据错误码把<code>mmFileStat_</code>设置为对应的界面，如果<code>code</code>正常的话，其实这步会被跳过</p><p>调用<code>AddStateLine_</code>添加状态行</p><p>调用<code>AddHeader_</code>加入消息头</p><p>调用<code>AddContent_</code>添加消息内容</p><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a><code>Buffer</code></h2><p><code>buffer</code>主要管理的是字符串的在并发场景下的存储和读取，从<code>buffer</code>的成员变量来看，<code>buffer</code>的组成是非常简单的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::vector&lt;char&gt; buffer_;std::atomic&lt;std::size_t&gt; readPos_;std::atomic&lt;std::size_t&gt; writePos_;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>一个可扩容的<code>vector</code></li><li><code>atomic</code>类型的<code>readPos_</code>和<code>writePos_</code>组成，<code>readPos_</code>表示读操作应该开始的位置，<code>writePos_</code>表示写操作应该开始的位置，<code>readPos_</code>和<code>writePos_</code>之间的区域则是写入了但还没有读的区域。</li></ul><p> 主要方法包括：</p><ul><li><code>retrieve(size_t len)</code>: 将<code>readPos_</code>向后移动<code>len</code></li><li><code>retrieveAll()</code>: <code>readPos_</code>和<code>writePos</code>都置为0</li><li><code>RetrieveAllToStr()</code>: 将<code>readPos_</code>和<code>writePos</code>读入到<code>string</code>中</li><li><code>MakeSpace(int len)</code>: 判断能写入的区域是否能容纳下写入的长度，不能的话就<code>resize</code>一下<code>buffer</code>，否则把待写的内容移动到<code>buffer</code>的最前端</li><li><code>Append(const char *str, size_t len)</code>: 先确保空间可用，不够就扩容，之后用<code>copy</code>函数将数据写入到<code>buffer</code>中，更新<code>writePos_</code></li><li><code>ReadFd(int fd, int *saveErrno)</code>: 使用<code>readv</code>函数从<code>fd</code>中读取内容到<code>buffer</code>中</li><li><code>WriteFd(int fd, int *saveErrno)</code>: 使用<code>write</code>函数将<code>buffer</code>内容写到<code>fd</code>中</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webserver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebserver源码阅读（一）</title>
      <link href="/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/12/15/TinyWebserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="主程序的步骤"><a href="#主程序的步骤" class="headerlink" title="主程序的步骤"></a>主程序的步骤</h1><p>在本部分，主要去解析WebServer的四个主要组成部分</p><ul><li>Webserver类：供<code>main</code>函数使用的<code>webserver</code>主类，通过该类可以进行网络通信的各种连接</li><li>Epoll类：通过<code>epoll</code>函数进行系统调用</li><li>Thread类：负责线程池的管理</li><li>Sql资源管理部分<br>从<code>main.cpp</code>中，我们可以看到，主程序做了两件事</li><li>创建一个<code>webServer</code></li><li>调用了<code>server.start()</code> 启动创建的<code>server</code></li></ul><h2 id="1-WebServer类"><a href="#1-WebServer类" class="headerlink" title="1 WebServer类"></a>1 WebServer类</h2><p>下面进入到<code>WebServer</code>类的代码中一探究竟</p><h3 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h3><p>在列表初始化中，初始化了<code>port</code>,<code>Timer</code>,<code>ThreadPool</code>,<code>Epoller</code><br>在构造函数中主要包含了以下步骤</p><ol><li>初始化<code>HttpConn</code>的静态变量，包括<ul><li><code>userCount</code>: 默认为0</li><li><code>srcDir</code>: <code>getcwd + &#39;/resources/&#39;</code></li></ul></li><li>初始化<code>SqlConnPool</code></li><li>初始化<code>Webserver</code>的<code>eventMode_</code></li><li><code>InitSocket_</code>:<ul><li>主要包含初始化socket的各种配置，创建<code>listenFd</code></li></ul></li><li>初始化<code>log</code></li></ol><p><code>InitSocket_</code>具体包含：</p><blockquote><ul><li>创建socket</li><li>设置数据没发送完毕的时候容许逗留（<a href="https://www.cnblogs.com/eeexu123/p/5275783.html">setsockopt用法介绍</a>）<br>  <code>setsockopt(listenFd_, SOL_SOCKET, SO_LINGER, &amp;optLinger, sizeof(optLinger));</code></li><li>设置端口复用 <code>setsockopt(listenFd_, SOL_SOCKET, SO_REUSEADDR, (const void*)&amp;optval, sizeof(int));</code></li><li>bind + listen</li><li>添加fd到监听红黑树上<ul><li>实际通过<code>Epoller</code>类进行操作，核心代码为<code>epoll_ctl(epollFd_, EPOLL_CTL_ADD, fd, &amp;ev)</code></li><li>修改<code>listenFd_</code>为非阻塞: <code>SetFdNonBlock(listenFd_)</code></li></ul></li></ul></blockquote><h3 id="1-2-WebServer的启动"><a href="#1-2-WebServer的启动" class="headerlink" title="1.2 WebServer的启动"></a>1.2 WebServer的启动</h3><p>涉及到的是<code>WebServer Start</code>部分的代码，<code>timeMS</code>表示事件等待超时的时间</p><ol><li>判断<code>isClose_</code>是否为<code>true</code>，不为<code>true</code>时一直停留在循环内部（步骤2-步骤4）</li><li>通过<code>timer</code>更新<code>timeMS</code></li><li>调用<code>int eventCnt = epoller_-&gt;Wait(timeMS);</code>获取满足监听事件的总数</li><li>遍历获取的事件对事件进行处理<ul><li>如果是<code>listenfd_</code>，调用<code>DealListen_()</code></li><li>如果<code>EPOLLRDHUP | EPOLLHUP | EPOLLERROR</code>调用<code>CloseConn_()</code></li><li>如果是<code>EPOLLIN</code>，调用<code>DealRead_()</code></li><li>如果是<code>EPOLLOUT</code>，调用<code>DealWrite_()</code></li></ul></li><li>跳转至步骤1</li></ol><ul><li><code>DealListen_()</code>的处理</li></ul><blockquote><ul><li>调用<code>accept</code><ul><li>出错处理</li></ul></li><li>添加<code>client</code><ul><li>在<code>AddClient_</code>中执行</li><li>包括添加到<code>timer</code>，调用<code>epoller_-&gt;AddFd</code>添加到监听红黑树上，设置<code>nonblock</code>等一系列步骤</li></ul></li></ul></blockquote><ul><li><code>CloseConn_()</code>的处理</li></ul><blockquote><ul><li><code>epoller_-&gt;DelFd()</code></li><li><code>client</code>关闭连接</li></ul></blockquote><ul><li><code>DealRead_()</code>&#x2F;<code>DealWrite_()</code>的处理</li></ul><blockquote><ul><li>延长时间</li><li>加入<code>threadPool</code></li></ul></blockquote><h2 id="2-Epoller类"><a href="#2-Epoller类" class="headerlink" title="2 Epoller类"></a>2 Epoller类</h2><p><code>Epoller</code>非常简单，主要是对<code>epoll</code>操作的封装，内部用<code>vector&lt;struct epoll_event&gt; events</code>存储监听树上的事件<br>主要方法如下</p><ul><li><code>AddFd(int fd, uint32_t event)</code></li><li><code>ModFd(int fd, uint32_t event)</code></li><li><code>DelFd(int fd)</code></li><li><code>Wait(int timeoutMs)</code></li><li><code>GetEventFd(size_t i)</code></li><li><code>GetEvents(size_t i)</code><br>这里可以直接参考<code>epoll</code>的用法</li></ul><h2 id="3-Thread类"><a href="#3-Thread类" class="headerlink" title="3 Thread类"></a>3 Thread类</h2><p>核心代码在<code>pool/threadPool</code>中，在<code>ThreadPool</code>成员变量为<code>Pool</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Pool &#123;    std::mutex mtx;    std::condition_variable cond;    bool isClosed;    std::queue&lt;std::function&lt;void()&gt;&gt; tasks; &#125;; std::shared_ptr&lt;Pool&gt; pool_;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对其进行分析，里面主要含有锁<code>mutex</code>，条件变量<code>cond</code>，是否关闭<code>isClosed</code>，函数组成的队列<code>queue&lt;std::function&lt;void()&gt;&gt; tasks</code><br><code>pool</code>是多个线程之间的共享资源，因为对<code>pool</code>的所有操作都需要先获取锁</p><h3 id="3-1-线程池"><a href="#3-1-线程池" class="headerlink" title="3.1 线程池"></a>3.1 线程池</h3><p>首先来到构造函数，它做的事是</p><ul><li>初始化<code>pool_</code>: 这里采用<code>make_shared</code>进行初始化（<a href="https://www.jianshu.com/p/03eea8262c11">c11 make_shared</a>），构造函数建议使用<code>make_shared</code>而不是<code>new</code>分配对象</li><li>创建<code>threadCount</code>个线程：用<code>detach</code>方法作为后台线程，线程的使用可以参考<a href="https://thispointer.com/c11-multithreading-part-2-joining-and-detaching-threads/">joining-and-detaching-threads</a></li></ul><p>创建的后台线程做的事如下：<br>    - 使用<code>std::unique_lock</code>创建一个锁（<a href="https://blog.csdn.net/shoufei403/article/details/107510476">使用方法</a>），该构造方法会直接对<code>mutex</code>对象加锁<br>    - while循环中<br>        - 当<code>tasks</code>不为空时，可以看到已经获取了<code>lock</code>，取出第一个<code>task</code>，释放<code>lock</code>,执行<code>task</code>，最后获取锁进到下一次循环中<br>        - 当<code>tasks</code>为空时，如果有停止标志，退出循环，否则等待<br>        - 当 <code>std::condition_variable</code> 对象的某个 wait 函数被调用的时候，它使用 <code>std::unique_lock</code>(通过 <code>std::mutex</code>) 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的 <code>std::condition_variable</code> 对象上调用了 <code>notification</code> 函数来唤醒当前线程<br>            - 观察到在<code>addTask</code>方法中， <code>pool_-&gt;cond.notify_one()</code>会将其唤醒</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">explicit ThreadPool(size_t threadCount &#x3D; 8): pool_(std::make_shared&lt;Pool&gt;()) &#123;        assert(threadCount &gt; 0);        for(size_t i &#x3D; 0; i &lt; threadCount; i++) &#123;            std::thread([pool &#x3D; pool_] &#123;                std::unique_lock&lt;std::mutex&gt; locker(pool-&gt;mtx);                while(true) &#123;                    if(!pool-&gt;tasks.empty()) &#123;                        auto task &#x3D; std::move(pool-&gt;tasks.front());                        pool-&gt;tasks.pop();                        locker.unlock();                        task();                        locker.lock();                    &#125;                     else if(pool-&gt;isClosed) break;                    else pool-&gt;cond.wait(locker);                &#125;            &#125;).detach();        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-回调函数的放入"><a href="#3-2-回调函数的放入" class="headerlink" title="3.2 回调函数的放入"></a>3.2 回调函数的放入</h3><p><code>std::function&lt;void()&gt;</code>是可调用对象包装器，可用于<code>callback</code>，参考<a href="https://stackoverflow.com/questions/11352936/why-do-we-use-stdfunction-in-c-rather-than-the-original-c-function-pointer">why use std::function</a>,  <a href="https://stackoverflow.com/questions/55124517/stdfunction-and-stdbind-return-value">std::function and std::bind</a>, <a href="https://blog.csdn.net/Jxianxu/article/details/107382049">std::bind</a></p><p>整个放入到tasks到流程如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">threadpool_-&gt;AddTask(std::bind(&amp;WebServer::OnWrite_, this, client))void AddTask(F&amp;&amp; task) &#123;    &#123;        std::lock_guard&lt;std::mutex&gt; locker(pool_-&gt;mtx);        pool_-&gt;tasks.emplace(std::forward&lt;F&gt;(task));    &#125;    pool_-&gt;cond.notify_one();&#125;std::queue&lt;std::function&lt;void()&gt;&gt; tasks;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::bind</code>将<code>client</code>参数绑定到<code>WebServer::OnWrite_</code>方法，这样返回的<code>functor</code>就变为<code>void()</code>，放入到<code>std::function&lt;void()&gt;</code>可调用对象包装器中。</p><h3 id="3-3-析构函数"><a href="#3-3-析构函数" class="headerlink" title="3.3 析构函数"></a>3.3 析构函数</h3><p>在析构函数中，需要唤醒阻塞的后台进程，使其结束。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">~ThreadPool() &#123;    if(static_cast&lt;bool&gt;(pool_)) &#123;        &#123;            std::lock_guard&lt;std::mutex&gt; locker(pool_-&gt;mtx);            pool_-&gt;isClosed &#x3D; true;        &#125;        pool_-&gt;cond.notify_all();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-Sql资源管理"><a href="#4-Sql资源管理" class="headerlink" title="4 Sql资源管理"></a>4 Sql资源管理</h2><p>主要包含以下文件：<code>sqlConnRAII.h</code>, <code>sqlconnpool.h</code>, <code>sqlconnpool.c</code></p><h3 id="4-1-RAII机制"><a href="#4-1-RAII机制" class="headerlink" title="4.1 RAII机制"></a>4.1 RAII机制</h3><p>RAII（Resource Acquisition Is Initialization）为资源获取即初始化，<code>sqlConnRAII.h</code>专门负责了sql资源的连接，关键代码为在构造函数中调用<code>*sql = connpool-&gt;GetConn();</code>，在析构函数中调用<code>connpool_-&gt;FreeConn(sql_);</code><br>内部成员有两个：</p><ul><li><code>MYSQL *sql_;</code></li><li><code>SqlConnPool* connpool_;</code></li></ul><h3 id="4-2-SqlConnPool"><a href="#4-2-SqlConnPool" class="headerlink" title="4.2 SqlConnPool"></a>4.2 SqlConnPool</h3><p><code>sqlconnpool.h</code>中，静态方法为<code>instance</code>: 它用static声明了一个<code>SqlConnPool</code>对象并返回了一个地址<br>成员方法包括</p><ul><li><code>MYSQL *GetConn()</code></li><li><code>void FreeConn(MYSQL conn)</code></li><li><code>int GetFreeConnCount()</code></li><li><code>void Init(args)</code></li><li><code>void ClosePool()</code><br>成员变量包括</li><li><code>std::queue&lt;MYSQL *&gt; connQue_</code>;</li><li><code>std::mutex mtx_</code>;</li><li><code>sem_t semId_</code>;</li><li><code>int MAX_CONN_</code>;</li></ul><h4 id="4-2-1-Init和ClosePool"><a href="#4-2-1-Init和ClosePool" class="headerlink" title="4.2.1 Init和ClosePool"></a>4.2.1 Init和ClosePool</h4><p>首先来到<code>init</code>方法，它调用<code>connSize</code>次<br>    - <code>mysql_init</code><br>    - <code>mysql_real_connect</code><br>    - 并<code>MYSQL</code>对象添加到<code>connQue_</code>中<br>之后初始化<code>MAC_CONN_</code>和初始化信号量<code>semId_</code>为<code>MAX_CONN_</code><br>在<code>ClosePool</code>中，主要做的事情是清空<code>connQue_</code>,调用<code>mysql_library_end</code>结束<code>mysql</code></p><h4 id="4-2-2-GetConn和FreeConn"><a href="#4-2-2-GetConn和FreeConn" class="headerlink" title="4.2.2 GetConn和FreeConn"></a>4.2.2 GetConn和FreeConn</h4><p>这里采用sem和<a href="https://blog.csdn.net/fengbingchun/article/details/78649260">lock_guard</a>对多线程并发访问进行控制，<code>sem_wait</code>和<code>sem_post</code>对连接数进行原子操作，<code>lock_guard</code>在构造时会自动获取锁，析构时会释放锁，用来取出<code>sql</code>对象</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MYSQL* SqlConnPool::GetConn() &#123;    MYSQL *sql &#x3D; nullptr;    if(connQue_.empty())&#123;        LOG_WARN(&quot;SqlConnPool busy!&quot;);        return nullptr;    &#125;    sem_wait(&amp;semId_);    &#123;        lock_guard&lt;mutex&gt; locker(mtx_);        sql &#x3D; connQue_.front();        connQue_.pop();    &#125;    return sql;&#125;void SqlConnPool::FreeConn(MYSQL* sql) &#123;    assert(sql);    lock_guard&lt;mutex&gt; locker(mtx_);    connQue_.push(sql);    sem_post(&amp;semId_);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>c11语法: <a href="https://www.codeproject.com/Articles/312029/Cplusplus-A-Glance-Part-of-n">Cplusplus-A-Glance-Part-of-n</a></li><li>c++多线程编程：<a href="https://www.cnblogs.com/haippy/p/3235560.html">C++11 并发指南</a></li><li>writev和readv：<a href="https://blog.csdn.net/weixin_36750623/article/details/84579243">高级I&#x2F;O之readv和writev函数</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webserver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile</title>
      <link href="/2022/12/03/makefile/"/>
      <url>/2022/12/03/makefile/</url>
      
        <content type="html"><![CDATA[<h2 id="MakeFile工作原理"><a href="#MakeFile工作原理" class="headerlink" title="MakeFile工作原理"></a>MakeFile工作原理</h2><h3 id="一个规则"><a href="#一个规则" class="headerlink" title="一个规则"></a>一个规则</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">目标: 依赖条件生成方法<span class="token number">1</span>. 目标生成的时间必须晚于依赖条件的时间，否则，更新目录<span class="token number">2</span>. 依赖条件如果不存在，寻找新的规则去产生依赖hello:hello.cgcc hello.c <span class="token parameter variable">-o</span> hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会先检查依赖条件是否满足，如果满足则会执行，下面给出一个编译的例子</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ALL:a.out 指定makefile的终极目标a.out:hello.o add.o sub.o div.ogcc hello.o add.o sub.o div.o <span class="token parameter variable">-o</span> a.outhello.o:hello.cgcc <span class="token parameter variable">-c</span> hello.c <span class="token parameter variable">-o</span> hello.oadd.o:add.cgcc <span class="token parameter variable">-c</span> add.c <span class="token parameter variable">-o</span> add.osub.o:sub.cgcc <span class="token parameter variable">-c</span> sub.c <span class="token parameter variable">-o</span> sub.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任一个被更新，则目标必须更新</p><h3 id="两个函数"><a href="#两个函数" class="headerlink" title="两个函数"></a>两个函数</h3><p><code>$(wildcard *.c)</code>将后面格式<code>.c</code>的文件都提取出来，将文件名组成列表</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">src <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>wildcard *.c<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>$(patsubst %.c, %.o, $(src))</code>：将参数3中，包含参数1的部分，替换为参数2</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">src <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>wildcard *.c<span class="token variable">)</span></span> obj <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>patsubst %.c, %.o, <span class="token punctuation">$(</span>src<span class="token punctuation">)</span><span class="token variable">)</span></span>myargs <span class="token operator">=</span> <span class="token parameter variable">-Wall</span> <span class="token parameter variable">-g</span>a.out:<span class="token variable"><span class="token variable">$(</span>obj<span class="token variable">)</span></span>gcc <span class="token variable"><span class="token variable">$(</span>obj<span class="token variable">)</span></span> <span class="token parameter variable">-o</span> a.out <span class="token variable"><span class="token variable">$(</span>myargs<span class="token variable">)</span></span>clean:<span class="token parameter variable">-rm</span> <span class="token parameter variable">-rf</span> <span class="token variable"><span class="token variable">$(</span>obj<span class="token variable">)</span></span> a.out <span class="token comment">#前面的-表示出错仍旧执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>clean</code>的模拟执行：<code>make clean -n</code>，不会实际执行</p><h3 id="三个自动变量"><a href="#三个自动变量" class="headerlink" title="三个自动变量"></a>三个自动变量</h3><ul><li><code>$@</code>: 在规则的命令中，表示规则中的目标</li><li><code>$^</code>: 在规则的命令中，表示第所有依赖条件</li><li><code>$&lt;</code>: 在规则的命令中，表示第一个依赖条件，如果将该变量应用在模式规则中，可将依赖条件列表依次去除，套用模式规则</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">src <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>wildcard *.c<span class="token variable">)</span></span> obj <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>patsubst %.c, %.o, <span class="token punctuation">$(</span>src<span class="token punctuation">)</span><span class="token variable">)</span></span>a.out:<span class="token variable"><span class="token variable">$(</span>obj<span class="token variable">)</span></span>gcc $^ <span class="token parameter variable">-o</span> <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">%o:%.cgcc $<span class="token operator">&lt;</span> <span class="token parameter variable">-o</span> <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>静态模式规则：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>obj<span class="token variable">)</span></span>:%.o:%.cgcc <span class="token parameter variable">-c</span> $<span class="token operator">&lt;</span> <span class="token parameter variable">-o</span> <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>伪目标</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.PHONY: clean ALL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc使用</title>
      <link href="/2022/12/02/gcc%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/12/02/gcc%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="gcc编译"><a href="#gcc编译" class="headerlink" title="gcc编译"></a>gcc编译</h2><h3 id="编译的四个步骤"><a href="#编译的四个步骤" class="headerlink" title="编译的四个步骤"></a>编译的四个步骤</h3><ul><li>预处理(<code>gcc -E</code>)：展开宏、头文件，替换条件编译、删除注释、空行、空白(<code>hello.i</code>)</li><li>编译(<code>gcc -S</code>)：检查语法规范，得到汇编码(<code>hello.s</code>)</li><li>汇编(<code>gcc -c</code>)：将汇编指令翻译成机器码(<code>hello.o</code>)</li><li>链接：<strong>数据段合并，数据地址回填</strong>（<code>a.out</code>）</li></ul><p>消耗时间和系统资源最多的是<strong>编译阶段</strong></p><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-I: 指定头文件所在目录位置-c：只做预处理 编译 汇编操作-g：编译时添加调试文件-On: <span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token number">0</span>~3, 优化程度-Wall: 显示所有的警告信息-D: 向程序中注册宏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h3><p>使用场景</p><ul><li>动态库：对时间要求较低，对空间要求较高</li><li>静态库：对空间要求较低，对时间要求较高</li></ul><h4 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">先用gcc -c生成.o文件，再用ar生成库名ar rcs mylib.a add.o sub.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h4><p>需要生成与位置无关的代码，在绑定动态库时会延迟绑定，通过汇编中@plt中进行判断</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc add.c <span class="token parameter variable">-o</span> add.o -fPIC<span class="token punctuation">(</span>生成位置无关代码<span class="token punctuation">)</span>gcc <span class="token parameter variable">-shared</span> lib库名.so add.o sub.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>编译可执行文件时，用<code>-l</code>指定库名，<code>-L</code>指定路径</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc test.c <span class="token parameter variable">-o</span> a.out <span class="token parameter variable">-lmymath</span> -L./lib -I./include<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>链接器：工作在链接阶段，工作时需要<code>-l</code>和<code>-L</code></p><p>动态链接器：工作在运行阶段</p><p>由于动态库时运行时加载的，程序需要找到动态库的位置，需要设置环境变量，<code>export LD_LIBRARY_PATH=动态库路径</code></p><p>查看程序执行时要加载哪些动态库以及动态库路径</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ldd a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用指令</title>
      <link href="/2022/12/01/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/12/01/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="进程监控"><a href="#进程监控" class="headerlink" title="进程监控"></a>进程监控</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>显示进程信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> 进程号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>强制关闭进程</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> <span class="token parameter variable">-9</span> 进程号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="主机状态监控"><a href="#主机状态监控" class="headerlink" title="主机状态监控"></a>主机状态监控</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>查看系统整体资源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span> <span class="token parameter variable">-p</span> 只显示进程信息<span class="token parameter variable">-d</span> 设置刷新时间<span class="token parameter variable">-n</span> 指定刷新次数<span class="token parameter variable">-u</span> 查找特定用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以交互式进行，可以通过按键有各种功能</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>查看端口占用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> <span class="token parameter variable">-an</span> <span class="token operator">|</span> <span class="token function">grep</span> 端口号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>公认端口：1～1023，系统内置或常用知名软件绑定使用<br>注册端口：1024～49151:松散绑定（用户自定义）<br>动态端口：49152～65532:临时使用（多用于出口）</p><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>查看磁盘使用情况</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">df</span> <span class="token parameter variable">-h</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p>查看CPU、磁盘相关情况</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iostat <span class="token parameter variable">-x</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主要去关注三个指标</p><p>rKB&#x2F;S: 每秒发送到设备的读取请求数</p><p>wKB&#x2F;S: 每秒发送到设备的写入请求数</p><p>%util：磁盘利用率</p><h3 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h3><p>网络状态监控</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sar <span class="token parameter variable">-n</span> DEV<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h3><p>采用<code>env</code>查看，是<code>KEY-VALUE</code>的形式，可以通过<code>$</code>获得环境变量的值</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">env</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token environment constant">PATH</span><span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span>得到的就是执行程序的搜索路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><h4 id="临时生效"><a href="#临时生效" class="headerlink" title="临时生效"></a>临时生效</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">VAR</span><span class="token operator">=</span>xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="永久生效"><a href="#永久生效" class="headerlink" title="永久生效"></a>永久生效</h4><ul><li>对当前用户生效<br>  通过用户<code>home</code>目录下的<code>.bashrc</code>中<code>export</code></li><li>对全局有效<br>  通过<code>vim /etc/profile</code></li></ul><h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><p>常用2种压缩格式</p><ul><li><code>.tar</code>：简单封装</li><li><code>.gz</code>：极大减小压缩后的体积</li></ul><p>针对这两种格式，使用<code>tar</code>命令都可以进行压缩和解压缩的操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">压缩文件<span class="token punctuation">(</span>f一定要最后<span class="token punctuation">)</span><span class="token function">tar</span> <span class="token parameter variable">-cvf</span> test.tar <span class="token number">1</span>.txt <span class="token number">2</span>.txt <span class="token number">3</span>.txt <span class="token punctuation">(</span>会形成.tar<span class="token punctuation">)</span><span class="token function">tar</span> <span class="token parameter variable">-zcvf</span> test.tar <span class="token number">1</span>.txt <span class="token number">2</span>.txt <span class="token number">3</span>.txt<span class="token punctuation">(</span>会形成.gz<span class="token punctuation">)</span>解压文件<span class="token function">tar</span> <span class="token parameter variable">-xvf</span> test.tar <span class="token punctuation">(</span>到当前目录<span class="token punctuation">)</span><span class="token function">tar</span> <span class="token parameter variable">-xvf</span> test.tar <span class="token parameter variable">-C</span> /home <span class="token punctuation">(</span>-C 指定目的地<span class="token punctuation">)</span><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> test.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>zip</code>的使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">压缩文件<span class="token function">zip</span> test.zip a.txt b.txt<span class="token function">zip</span> <span class="token parameter variable">-r</span> test.zip <span class="token builtin class-name">test</span> a.txt b.txt<span class="token punctuation">(</span>带有文件夹时<span class="token punctuation">)</span>解压文件<span class="token function">unzip</span> test.zip <span class="token parameter variable">-d</span> 位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
